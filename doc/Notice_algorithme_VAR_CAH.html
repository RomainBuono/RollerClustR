<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notice_algorithme_var_cah</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Notice_algorithme_VAR_CAH_files/libs/clipboard/clipboard.min.js"></script>
<script src="Notice_algorithme_VAR_CAH_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Notice_algorithme_VAR_CAH_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Notice_algorithme_VAR_CAH_files/libs/quarto-html/popper.min.js"></script>
<script src="Notice_algorithme_VAR_CAH_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Notice_algorithme_VAR_CAH_files/libs/quarto-html/anchor.min.js"></script>
<link href="Notice_algorithme_VAR_CAH_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Notice_algorithme_VAR_CAH_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Notice_algorithme_VAR_CAH_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Notice_algorithme_VAR_CAH_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Notice_algorithme_VAR_CAH_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="implémentation-de-lalgorithme-var-cah-dans-la-classe-var_cah" class="level1">
<h1>Implémentation de l’Algorithme VAR-CAH dans la Classe VAR_CAH</h1>
<section id="fondements-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="fondements-théoriques">1. Fondements Théoriques</h2>
<section id="principe-général" class="level3">
<h3 class="anchored" data-anchor-id="principe-général">1.1 Principe Général</h3>
<p>L’implémentation proposée réalise un clustering hiérarchique de variables quantitatives selon une approche VAR-CAH (Variables - Classification Ascendante Hiérarchique). L’objectif consiste à regrouper des variables présentant de fortes corrélations en ensembles homogènes, puis à synthétiser l’information de chaque groupe par une variable latente unidimensionnelle.</p>
<p>Cette approche s’inscrit dans le paradigme de la réduction de dimensionnalité supervisée, où la structure de corrélation entre variables guide la formation des groupes, et où chaque groupe est ensuite représenté par sa composante principale dominante.</p>
</section>
<section id="architecture-logicielle" class="level3">
<h3 class="anchored" data-anchor-id="architecture-logicielle">1.2 Architecture Logicielle</h3>
<p>La classe <code>VAR_CAH</code> hérite de la classe abstraite <code>ClusterAnalysis</code> et implémente une architecture R6 garantissant l’encapsulation des données et la réutilisabilité des méthodes. Les attributs privés assurent la persistance des résultats intermédiaires nécessaires aux prédictions ultérieures.</p>
</section>
</section>
<section id="traduction-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="traduction-algorithmique">2. Traduction Algorithmique</h2>
<section id="phase-de-prétraitement" class="level3">
<h3 class="anchored" data-anchor-id="phase-de-prétraitement">2.1 Phase de Prétraitement</h3>
<section id="nettoyage-des-données" class="level4">
<h4 class="anchored" data-anchor-id="nettoyage-des-données">Nettoyage des Données</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>X_clean <span class="ot">&lt;-</span> super<span class="sc">$</span><span class="fu">fit</span>(X)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FVarNames <span class="ot">&lt;-</span> <span class="fu">names</span>(X_clean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La méthode héritée <code>super$fit()</code> réalise la validation du jeu de données, incluant la vérification du type des variables et le traitement des valeurs manquantes selon la stratégie définie (<code>na_action</code>). Seules les variables numériques sont conservées pour l’analyse, conformément aux exigences de l’analyse en composantes principales ultérieure.</p>
</section>
</section>
<section id="construction-de-la-matrice-de-dissimilarité" class="level3">
<h3 class="anchored" data-anchor-id="construction-de-la-matrice-de-dissimilarité">2.2 Construction de la Matrice de Dissimilarité</h3>
<section id="calcul-de-la-matrice-de-corrélation" class="level4">
<h4 class="anchored" data-anchor-id="calcul-de-la-matrice-de-corrélation">Calcul de la Matrice de Corrélation</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>cor_matrix <span class="ot">&lt;-</span> <span class="fu">cor</span>(X_clean, <span class="at">use =</span> <span class="st">"pairwise.complete.obs"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>dist_vars <span class="ot">&lt;-</span> <span class="fu">as.dist</span>(<span class="dv">1</span> <span class="sc">-</span> <span class="fu">abs</span>(cor_matrix))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La dissimilarité entre variables est définie par la transformation :</p>
<p><span class="math display">\[d(X_i, X_j) = 1 - |\rho(X_i, X_j)|\]</span></p>
<p>où <span class="math inline">\(\rho(X_i, X_j)\)</span> désigne le coefficient de corrélation de Pearson entre les variables <span class="math inline">\(X_i\)</span> et <span class="math inline">\(X_j\)</span>. L’utilisation de la valeur absolue garantit que des variables fortement corrélées négativement sont considérées comme similaires, ce qui est pertinent dans un contexte de synthèse dimensionnelle.</p>
<p>L’option <code>use = "pairwise.complete.obs"</code> permet une estimation robuste en présence de données manquantes, en calculant chaque corrélation sur l’ensemble des observations disponibles pour la paire de variables considérée.</p>
</section>
</section>
<section id="classification-hiérarchique-ascendante" class="level3">
<h3 class="anchored" data-anchor-id="classification-hiérarchique-ascendante">2.3 Classification Hiérarchique Ascendante</h3>
<section id="construction-du-dendrogramme" class="level4">
<h4 class="anchored" data-anchor-id="construction-du-dendrogramme">Construction du Dendrogramme</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FArbre <span class="ot">&lt;-</span> <span class="fu">hclust</span>(dist_vars, <span class="at">method =</span> <span class="st">"ward.D2"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>groupes_vars <span class="ot">&lt;-</span> <span class="fu">cutree</span>(private<span class="sc">$</span>FArbre, <span class="at">k =</span> private<span class="sc">$</span>FNbGroupes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La classification ascendante hiérarchique est réalisée selon le critère de Ward, qui minimise l’inertie intra-classe à chaque étape de fusion. Plus formellement, à chaque itération, on agrège les clusters <span class="math inline">\(C_i\)</span> et <span class="math inline">\(C_j\)</span> qui minimisent l’augmentation de variance :</p>
<p><span class="math display">\[\Delta(C_i, C_j) = \frac{n_i n_j}{n_i + n_j} \|m_i - m_j\|^2\]</span></p>
<p>où <span class="math inline">\(n_i\)</span> et <span class="math inline">\(n_j\)</span> représentent les effectifs des clusters, et <span class="math inline">\(m_i\)</span> et <span class="math inline">\(m_j\)</span> leurs centroïdes respectifs.</p>
<p>La partition finale est obtenue par coupure de l’arbre hiérarchique au niveau <span class="math inline">\(k\)</span> spécifié, produisant <span class="math inline">\(k\)</span> groupes de variables disjoints.</p>
</section>
</section>
<section id="synthèse-par-composante-principale" class="level3">
<h3 class="anchored" data-anchor-id="synthèse-par-composante-principale">2.4 Synthèse par Composante Principale</h3>
<section id="extraction-de-la-variable-latente" class="level4">
<h4 class="anchored" data-anchor-id="extraction-de-la-variable-latente">Extraction de la Variable Latente</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>pca_synthetique <span class="ot">=</span> <span class="cf">function</span>(X_cluster) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  X_clean <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(X_cluster)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  pca_res <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(X_clean, <span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> private<span class="sc">$</span>FScale)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  full_synthetique <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA_real_</span>, <span class="fu">nrow</span>(X_cluster))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  full_synthetique[<span class="fu">as.numeric</span>(<span class="fu">rownames</span>(X_clean))] <span class="ot">&lt;-</span> pca_res<span class="sc">$</span>x[, <span class="dv">1</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">synthetic =</span> full_synthetique,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">loadings =</span> pca_res<span class="sc">$</span>rotation[, <span class="dv">1</span>],</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">center =</span> pca_res<span class="sc">$</span>center,</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">scale =</span> pca_res<span class="sc">$</span>scale,</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">variance_explained =</span> pca_res<span class="sc">$</span>sdev[<span class="dv">1</span>]<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> <span class="fu">sum</span>(pca_res<span class="sc">$</span>sdev<span class="sc">^</span><span class="dv">2</span>),</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">n_vars =</span> <span class="fu">ncol</span>(X_clean)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Pour chaque cluster <span class="math inline">\(C_k\)</span> de variables, une analyse en composantes principales est effectuée. La première composante principale (PC1) est retenue comme variable synthétique <span class="math inline">\(S_k\)</span>, celle-ci maximisant la variance expliquée dans l’espace des variables du cluster.</p>
<p>Mathématiquement, <span class="math inline">\(S_k\)</span> est définie par :</p>
<p><span class="math display">\[S_k = \sum_{j \in C_k} w_j X_j\]</span></p>
<p>où les poids <span class="math inline">\(w_j\)</span> correspondent au premier vecteur propre de la matrice de covariance (ou corrélation si standardisation) des variables de <span class="math inline">\(C_k\)</span>.</p>
</section>
<section id="gestion-des-cas-particuliers" class="level4">
<h4 class="anchored" data-anchor-id="gestion-des-cas-particuliers">Gestion des Cas Particuliers</h4>
<p>Lorsqu’un cluster ne contient qu’une seule variable, celle-ci est directement utilisée comme variable synthétique, avec une variance expliquée fixée à 1.0 par convention. Cette approche évite les complications numériques liées à l’ACP sur un espace unidimensionnel.</p>
</section>
<section id="persistance-des-paramètres" class="level4">
<h4 class="anchored" data-anchor-id="persistance-des-paramètres">Persistance des Paramètres</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pca_params[[k_idx]] <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">loadings =</span> pca_result<span class="sc">$</span>loadings,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">center =</span> pca_result<span class="sc">$</span>center,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">scale =</span> pca_result<span class="sc">$</span>scale,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">variance_explained =</span> pca_result<span class="sc">$</span>variance_explained,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">variables =</span> vars_in_cluster</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FPCAParams <span class="ot">&lt;-</span> pca_params</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Les paramètres de l’ACP (loadings, paramètres de centrage et réduction) sont stockés pour chaque cluster. Cette persistance est essentielle pour la projection ultérieure de nouvelles variables sans nécessiter un réajustement complet du modèle.</p>
</section>
</section>
<section id="évaluation-de-lhomogénéité" class="level3">
<h3 class="anchored" data-anchor-id="évaluation-de-lhomogénéité">2.5 Évaluation de l’Homogénéité</h3>
<section id="mesure-de-cohésion-intra-cluster" class="level4">
<h4 class="anchored" data-anchor-id="mesure-de-cohésion-intra-cluster">Mesure de Cohésion Intra-Cluster</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vars_in_cluster)) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  var_name <span class="ot">&lt;-</span> vars_in_cluster[i]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  cor_val <span class="ot">&lt;-</span> <span class="fu">cor</span>(X_cluster[, var_name], pca_result<span class="sc">$</span>synthetic, </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">use =</span> <span class="st">"pairwise.complete.obs"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  correlations[<span class="fu">match</span>(var_name, private<span class="sc">$</span>FVarNames)] <span class="ot">&lt;-</span> <span class="fu">abs</span>(cor_val)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Pour chaque variable <span class="math inline">\(X_j\)</span> appartenant au cluster <span class="math inline">\(C_k\)</span>, on calcule sa corrélation avec la variable synthétique <span class="math inline">\(S_k\)</span> :</p>
<p><span class="math display">\[r_{jk} = \text{cor}(X_j, S_k)\]</span></p>
<p>Cette corrélation mesure dans quelle proportion la variable <span class="math inline">\(X_j\)</span> est expliquée par la composante synthétique de son cluster. Une corrélation élevée indique une forte cohésion entre la variable et son groupe.</p>
</section>
<section id="indices-globaux-de-qualité" class="level4">
<h4 class="anchored" data-anchor-id="indices-globaux-de-qualité">Indices Globaux de Qualité</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>qualite <span class="ot">&lt;-</span> <span class="fu">tapply</span>(correlations, groupes_vars, mean, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FQualiteClusters <span class="ot">&lt;-</span> qualite</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FHomogeneite <span class="ot">&lt;-</span> <span class="fu">sum</span>(correlations, <span class="at">na.rm =</span> <span class="cn">TRUE</span>) <span class="sc">/</span> n_vars</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Deux indices de qualité sont calculés :</p>
<ol type="1">
<li><p><strong>Homogénéité par cluster</strong> : moyenne des corrélations des variables avec leur synthétique respective <span class="math display">\[H(C_k) = \frac{1}{|C_k|} \sum_{j \in C_k} |r_{jk}|\]</span></p></li>
<li><p><strong>Homogénéité globale</strong> : moyenne de toutes les corrélations sur l’ensemble des variables <span class="math display">\[H_{global} = \frac{1}{p} \sum_{k=1}^{K} \sum_{j \in C_k} |r_{jk}|\]</span></p></li>
</ol>
<p>où <span class="math inline">\(p\)</span> désigne le nombre total de variables et <span class="math inline">\(K\)</span> le nombre de clusters.</p>
</section>
</section>
<section id="reconfiguration-dynamique" class="level3">
<h3 class="anchored" data-anchor-id="reconfiguration-dynamique">2.6 Reconfiguration Dynamique</h3>
<section id="modification-du-nombre-de-clusters" class="level4">
<h4 class="anchored" data-anchor-id="modification-du-nombre-de-clusters">Modification du Nombre de Clusters</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>refit_with_k <span class="ot">=</span> <span class="cf">function</span>(new_k) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(private<span class="sc">$</span>FArbre)) {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">stop</span>(<span class="st">"Le modèle n'est pas encore ajusté. Lancez $fit() d'abord."</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FNbGroupes <span class="ot">&lt;-</span> new_k</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  groupes_vars <span class="ot">&lt;-</span> <span class="fu">cutree</span>(private<span class="sc">$</span>FArbre, <span class="at">k =</span> new_k)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FGroupes <span class="ot">&lt;-</span> groupes_vars</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span><span class="fu">evaluate_clusters</span>()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette méthode permet de modifier le nombre de clusters sans réexécuter l’intégralité de l’algorithme. Le dendrogramme préalablement construit est simplement coupé à un nouveau niveau, puis les variables synthétiques et métriques de qualité sont recalculées. Cette approche tire parti de la nature hiérarchique de la méthode, où l’arbre de classification encode toutes les partitions possibles.</p>
</section>
</section>
</section>
<section id="prédiction-de-nouvelles-variables" class="level2">
<h2 class="anchored" data-anchor-id="prédiction-de-nouvelles-variables">3. Prédiction de Nouvelles Variables</h2>
<section id="principe-de-projection" class="level3">
<h3 class="anchored" data-anchor-id="principe-de-projection">3.1 Principe de Projection</h3>
<p>La méthode <code>predict_variable()</code> constitue une extension innovante permettant d’assigner de nouvelles variables à des clusters préexistants sans modifier la structure du clustering initial. Cette fonctionnalité repose sur le calcul d’un score de similarité entre chaque nouvelle variable et les clusters établis.</p>
</section>
<section id="méthode-par-corrélation-avec-les-synthétiques" class="level3">
<h3 class="anchored" data-anchor-id="méthode-par-corrélation-avec-les-synthétiques">3.2 Méthode par Corrélation avec les Synthétiques</h3>
<section id="implémentation" class="level4">
<h4 class="anchored" data-anchor-id="implémentation">Implémentation</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>score_correlation <span class="ot">=</span> <span class="cf">function</span>(new_var, cluster_id) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  synthetic <span class="ot">&lt;-</span> private<span class="sc">$</span>FSynthetiques[, cluster_id]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span>(<span class="fu">cor</span>(new_var, synthetic, <span class="at">use =</span> <span class="st">"pairwise.complete.obs"</span>))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le score d’appartenance d’une nouvelle variable <span class="math inline">\(Y\)</span> au cluster <span class="math inline">\(C_k\)</span> est calculé comme la valeur absolue de la corrélation entre <span class="math inline">\(Y\)</span> et la variable synthétique <span class="math inline">\(S_k\)</span> :</p>
<p><span class="math display">\[\text{score}_{\text{corr}}(Y, C_k) = |\text{cor}(Y, S_k)|\]</span></p>
<p><strong>Avantages</strong> : - Efficacité computationnelle : <span class="math inline">\(O(n)\)</span> par cluster, où <span class="math inline">\(n\)</span> est le nombre d’observations - Interprétation directe : mesure l’alignement avec la dimension principale du cluster - Cohérence avec la logique de construction des clusters (basée sur la première composante)</p>
<p><strong>Contexte d’application optimal</strong> : - Clusters bien représentés par leur première composante principale (variance expliquée élevée) - Besoin d’une assignation rapide pour un grand nombre de nouvelles variables</p>
</section>
</section>
<section id="méthode-par-distance-moyenne" class="level3">
<h3 class="anchored" data-anchor-id="méthode-par-distance-moyenne">3.3 Méthode par Distance Moyenne</h3>
<section id="implémentation-1" class="level4">
<h4 class="anchored" data-anchor-id="implémentation-1">Implémentation</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>score_distance <span class="ot">=</span> <span class="cf">function</span>(new_var, cluster_id) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  cluster_vars <span class="ot">&lt;-</span> <span class="fu">names</span>(private<span class="sc">$</span>FGroupes)[private<span class="sc">$</span>FGroupes <span class="sc">==</span> cluster_id]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  X_cluster <span class="ot">&lt;-</span> private<span class="sc">$</span>FX[, cluster_vars, drop <span class="ot">=</span> <span class="cn">FALSE</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  cors <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(X_cluster), <span class="cf">function</span>(i) {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">abs</span>(<span class="fu">cor</span>(new_var, X_cluster[, i], <span class="at">use =</span> <span class="st">"pairwise.complete.obs"</span>))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  score <span class="ot">&lt;-</span> <span class="fu">mean</span>(cors, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le score d’appartenance est ici calculé comme la moyenne des corrélations de la nouvelle variable avec toutes les variables du cluster :</p>
<p><span class="math display">\[\text{score}(Y, C_k) = \frac{1}{|C_k|} \sum_{j \in C_k} |\text{cor}(Y, X_j)|\]</span></p>
<p>Cette méthode évalue la proximité globale de la nouvelle variable avec l’ensemble du cluster, plutôt qu’avec sa seule représentation synthétique.</p>
<p><strong>Avantages</strong> : - Robustesse aux clusters déséquilibrés ou hétérogènes - Capture une notion de distance plus globale dans l’espace des variables - Moins sensible à une faible variance expliquée par PC1</p>
<p><strong>Contexte d’application optimal</strong> : - Clusters présentant une structure multidimensionnelle complexe - Situations où la première composante principale n’est pas suffisamment discriminante</p>
</section>
</section>
<section id="assignation-et-restitution-des-résultats" class="level3">
<h3 class="anchored" data-anchor-id="assignation-et-restitution-des-résultats">3.4 Assignation et Restitution des Résultats</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>assigned_clusters <span class="ot">&lt;-</span> <span class="fu">apply</span>(scores_matrix, <span class="dv">1</span>, which.max)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(assigned_clusters) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(new_variables)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (return_scores) {</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(scores_matrix)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  result<span class="sc">$</span>assigned_cluster <span class="ot">&lt;-</span> assigned_clusters</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(result)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(assigned_clusters)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Chaque nouvelle variable est assignée au cluster pour lequel le score calculé est maximal. L’utilisateur peut choisir entre : - Un vecteur d’assignations (mode par défaut) - Une matrice complète des scores pour tous les clusters (mode diagnostique)</p>
<p>La restitution des scores complets permet d’évaluer l’ambiguïté de l’assignation : des scores similaires pour plusieurs clusters suggèrent une variable à la frontière entre groupes.</p>
</section>
</section>
<section id="méthodes-utilitaires" class="level2">
<h2 class="anchored" data-anchor-id="méthodes-utilitaires">4. Méthodes Utilitaires</h2>
<section id="extraction-de-variables-par-cluster" class="level3">
<h3 class="anchored" data-anchor-id="extraction-de-variables-par-cluster">4.1 Extraction de Variables par Cluster</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>get_cluster_variables <span class="ot">=</span> <span class="cf">function</span>(cluster_id) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  vars <span class="ot">&lt;-</span> <span class="fu">names</span>(private<span class="sc">$</span>FGroupes)[private<span class="sc">$</span>FGroupes <span class="sc">==</span> cluster_id]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(vars)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette méthode retourne l’ensemble des variables appartenant à un cluster spécifié.</p>
</section>
<section id="identification-de-la-variable-représentative" class="level3">
<h3 class="anchored" data-anchor-id="identification-de-la-variable-représentative">4.2 Identification de la Variable Représentative</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>get_representative_variable <span class="ot">=</span> <span class="cf">function</span>(cluster_id) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  vars <span class="ot">&lt;-</span> self<span class="sc">$</span><span class="fu">get_cluster_variables</span>(cluster_id)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  cors <span class="ot">&lt;-</span> private<span class="sc">$</span>FCorrelations[<span class="fu">match</span>(vars, private<span class="sc">$</span>FVarNames)]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(vars[<span class="fu">which.max</span>(cors)])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Pour un cluster donné, la variable présentant la corrélation maximale avec la variable synthétique est identifiée comme représentative. Cette variable peut être utilisée comme proxy simplifié du cluster dans des analyses ultérieures.</p>
</section>
<section id="accès-au-dendrogramme" class="level3">
<h3 class="anchored" data-anchor-id="accès-au-dendrogramme">4.3 Accès au Dendrogramme</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>get_tree <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(private<span class="sc">$</span>FArbre)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>L’objet <code>hclust</code> sous-jacent est accessible pour visualisation (dendrogramme) ou analyses complémentaires de la structure hiérarchique.</p>
</section>
</section>
<section id="fondements-mathématiques-de-la-méthode" class="level2">
<h2 class="anchored" data-anchor-id="fondements-mathématiques-de-la-méthode">5. Fondements Mathématiques de la Méthode</h2>
<section id="justification-de-la-distance-basée-sur-la-corrélation" class="level3">
<h3 class="anchored" data-anchor-id="justification-de-la-distance-basée-sur-la-corrélation">5.1 Justification de la Distance Basée sur la Corrélation</h3>
<p>La distance <span class="math inline">\(d(X_i, X_j) = 1 - |\rho(X_i, X_j)|\)</span> satisfait les propriétés suivantes :</p>
<ol type="1">
<li><strong>Positivité</strong> : <span class="math inline">\(0 \leq d(X_i, X_j) \leq 2\)</span></li>
<li><strong>Symétrie</strong> : <span class="math inline">\(d(X_i, X_j) = d(X_j, X_i)\)</span></li>
<li><strong>Séparabilité</strong> : <span class="math inline">\(d(X_i, X_i) = 0\)</span></li>
</ol>
<p>Bien que cette métrique ne satisfasse pas strictement l’inégalité triangulaire, elle constitue une mesure de dissimilarité pertinente dans le contexte du clustering de variables, où l’objectif est de regrouper des variables colinéaires.</p>
</section>
<section id="optimalité-de-la-première-composante-principale" class="level3">
<h3 class="anchored" data-anchor-id="optimalité-de-la-première-composante-principale">5.2 Optimalité de la Première Composante Principale</h3>
<p>La première composante principale <span class="math inline">\(S_k\)</span> d’un cluster <span class="math inline">\(C_k\)</span> est solution du problème d’optimisation :</p>
<p><span class="math display">\[\max_{\|w\|=1} \text{Var}\left(\sum_{j \in C_k} w_j X_j\right)\]</span></p>
<p>Elle représente donc la combinaison linéaire des variables du cluster qui maximise la variance expliquée. Cette propriété garantit que <span class="math inline">\(S_k\)</span> constitue la meilleure synthèse unidimensionnelle de l’information contenue dans <span class="math inline">\(C_k\)</span> au sens des moindres carrés.</p>
</section>
<section id="interprétation-de-lhomogénéité" class="level3">
<h3 class="anchored" data-anchor-id="interprétation-de-lhomogénéité">5.3 Interprétation de l’Homogénéité</h3>
<p>L’indice d’homogénéité <span class="math inline">\(H(C_k)\)</span> quantifie la capacité de la variable synthétique à représenter les variables du cluster. Une valeur proche de 1 indique que <span class="math inline">\(S_k\)</span> capture efficacement la structure du cluster, suggérant une forte unidimensionnalité du groupe. Inversement, une homogénéité faible peut signaler la présence de sous-structures non capturées par la partition à <span class="math inline">\(k\)</span> clusters.</p>
</section>
</section>
<section id="complexité-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="complexité-algorithmique">6. Complexité Algorithmique</h2>
<section id="phase-dapprentissage" class="level3">
<h3 class="anchored" data-anchor-id="phase-dapprentissage">6.1 Phase d’Apprentissage</h3>
<ol type="1">
<li><strong>Calcul de la matrice de corrélation</strong> : <span class="math inline">\(O(p^2 n)\)</span> où <span class="math inline">\(p\)</span> est le nombre de variables et <span class="math inline">\(n\)</span> le nombre d’observations</li>
<li><strong>Classification hiérarchique</strong> : <span class="math inline">\(O(p^2 \log p)\)</span></li>
<li><strong>ACP par cluster</strong> : <span class="math inline">\(O\left(\sum_{k=1}^K p_k^2 n\right)\)</span> où <span class="math inline">\(p_k\)</span> est le nombre de variables dans le cluster <span class="math inline">\(k\)</span></li>
</ol>
<p>La complexité globale est dominée par le calcul de la matrice de corrélation initiale, soit <span class="math inline">\(O(p^2 n)\)</span>.</p>
</section>
<section id="phase-de-prédiction" class="level3">
<h3 class="anchored" data-anchor-id="phase-de-prédiction">6.2 Phase de Prédiction</h3>
<ul>
<li><strong>Méthode “correlation”</strong> : <span class="math inline">\(O(Kn)\)</span> où <span class="math inline">\(K\)</span> est le nombre de clusters</li>
<li><strong>Méthode “distance”</strong> : <span class="math inline">\(O(pn)\)</span> dans le pire cas (si un cluster contient toutes les variables)</li>
</ul>
<p>La méthode par corrélation est donc plus efficace pour un grand nombre de variables distribuées sur plusieurs clusters.</p>
</section>
</section>
<section id="limitations-et-extensions-possibles" class="level2">
<h2 class="anchored" data-anchor-id="limitations-et-extensions-possibles">7. Limitations et Extensions Possibles</h2>
<section id="limitations-actuelles" class="level3">
<h3 class="anchored" data-anchor-id="limitations-actuelles">7.1 Limitations Actuelles</h3>
<ol type="1">
<li><p><strong>Variables quantitatives uniquement</strong> : L’approche repose sur la corrélation de Pearson et l’ACP, limitant son application aux données numériques continues.</p></li>
<li><p><strong>Sensibilité aux valeurs aberrantes</strong> : La corrélation de Pearson étant sensible aux observations extrêmes, la structure de clustering peut être affectée par la présence d’outliers.</p></li>
<li><p><strong>Hypothèse de linéarité</strong> : Les relations non-linéaires entre variables ne sont pas capturées par la corrélation de Pearson.</p></li>
</ol>
</section>
<section id="perspectives-dextension" class="level3">
<h3 class="anchored" data-anchor-id="perspectives-dextension">7.2 Perspectives d’Extension</h3>
<ol type="1">
<li><p><strong>Support des variables catégorielles</strong> : Intégration de l’approche PCAMIX pour traiter conjointement variables quantitatives et qualitatives.</p></li>
<li><p><strong>Algorithme K-means itératif</strong> : Implémentation d’une variante par réallocation itérative, potentiellement plus efficace sur de grands ensembles de variables.</p></li>
<li><p><strong>Sélection automatique du nombre de clusters</strong> : Intégration de critères d’optimalité (silhouette, gap statistic) ou d’approches par bootstrap pour déterminer <span class="math inline">\(k\)</span> de manière objective.</p></li>
<li><p><strong>Robustification</strong> : Utilisation de corrélations robustes (Spearman, Kendall) ou de méthodes de détection d’outliers préalables.</p></li>
</ol>
</section>
</section>
<section id="cas-dusage-et-applications" class="level2">
<h2 class="anchored" data-anchor-id="cas-dusage-et-applications">8. Cas d’Usage et Applications</h2>
<section id="réduction-de-dimensionnalité" class="level3">
<h3 class="anchored" data-anchor-id="réduction-de-dimensionnalité">8.1 Réduction de Dimensionnalité</h3>
<p>Dans des contextes de haute dimensionnalité, cette approche permet de remplacer un ensemble de <span class="math inline">\(p\)</span> variables corrélées par <span class="math inline">\(k\)</span> variables synthétiques non corrélées, facilitant les analyses ultérieures (régression, classification).</p>
</section>
<section id="feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering">8.2 Feature Engineering</h3>
<p>La méthode <code>predict_variable()</code> offre un cadre formel pour évaluer l’intérêt de nouvelles variables dérivées. Des scores faibles sur tous les clusters suggèrent qu’une variable apporte une information complémentaire non redondante avec les variables existantes.</p>
</section>
<section id="détection-de-redondance" class="level3">
<h3 class="anchored" data-anchor-id="détection-de-redondance">8.3 Détection de Redondance</h3>
<p>L’identification de variables fortement représentatives dans chaque cluster permet de sélectionner un sous-ensemble parcimonieux de variables pour la modélisation, réduisant la multicolinéarité et les coûts de collecte de données.</p>
</section>
<section id="monitoring-et-maintenance-de-modèles" class="level3">
<h3 class="anchored" data-anchor-id="monitoring-et-maintenance-de-modèles">8.4 Monitoring et Maintenance de Modèles</h3>
<p>Dans des contextes de production, l’assignation incrémentale de nouvelles variables collectées permet de maintenir une cohérence avec la structure de clustering établie, sans nécessiter un réapprentissage complet.</p>
</section>
</section>
<section id="références-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="références-théoriques">9. Références Théoriques</h2>
<p>L’implémentation s’inspire des travaux suivants :</p>
<ul>
<li><strong>Chavent et al.&nbsp;(2012)</strong> : Formalisation de l’algorithme de clustering de variables et développement de méthodes VAR-CAH.</li>
<li><strong>Vigneau &amp; Qannari (2003)</strong> : Fondements théoriques du clustering de variables par composantes principales.</li>
<li><strong>Ward (1963)</strong> : Méthode de classification hiérarchique par minimisation de l’inertie intra-classe.</li>
</ul>
<p>La contribution distinctive de cette implémentation réside dans l’extension par la méthode <code>predict_variable()</code>, offrant une fonctionnalité de projection non disponible dans les implémentations standards.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>