<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notice_algorithme_varclus</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Notice_algorithme_VARCLUS_files/libs/clipboard/clipboard.min.js"></script>
<script src="Notice_algorithme_VARCLUS_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Notice_algorithme_VARCLUS_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Notice_algorithme_VARCLUS_files/libs/quarto-html/popper.min.js"></script>
<script src="Notice_algorithme_VARCLUS_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Notice_algorithme_VARCLUS_files/libs/quarto-html/anchor.min.js"></script>
<link href="Notice_algorithme_VARCLUS_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Notice_algorithme_VARCLUS_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Notice_algorithme_VARCLUS_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Notice_algorithme_VARCLUS_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Notice_algorithme_VARCLUS_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="implémentation-de-lalgorithme-varclus-dans-la-classe-varclus" class="level1">
<h1>Implémentation de l’Algorithme VARCLUS dans la Classe VARCLUS</h1>
<section id="fondements-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="fondements-théoriques">1. Fondements Théoriques</h2>
<section id="principe-général" class="level3">
<h3 class="anchored" data-anchor-id="principe-général">1.1 Principe Général</h3>
<p>L’algorithme VARCLUS (Variable Clustering) constitue une approche de partitionnement hiérarchique descendant pour le clustering de variables quantitatives. Contrairement aux méthodes ascendantes (agglomératives) qui fusionnent progressivement des variables similaires, VARCLUS procède par divisions successives d’un ensemble de variables en sous-groupes homogènes, jusqu’à ce qu’un critère d’arrêt statistique soit satisfait.</p>
<p>Cette approche s’inscrit dans la famille des algorithmes de partitionnement divisif, où la stratégie de segmentation repose sur l’analyse factorielle (ACP) et la rotation d’axes. L’objectif est d’identifier des groupes de variables mutuellement corrélées, chaque groupe étant caractérisé par une structure de corrélation unidimensionnelle dominante.</p>
</section>
<section id="fondement-algorithmique-division-récursive" class="level3">
<h3 class="anchored" data-anchor-id="fondement-algorithmique-division-récursive">1.2 Fondement Algorithmique : Division Récursive</h3>
<p>Le paradigme de division récursive distingue VARCLUS des approches hiérarchiques ascendantes classiques. À chaque étape, un groupe de variables est soumis à une analyse en composantes principales, et les deux premières composantes (après rotation) servent de base à une bipartition. Ce processus s’apparente à la construction d’un arbre binaire de décision, où chaque nœud interne représente une division en deux sous-groupes.</p>
</section>
<section id="architecture-logicielle" class="level3">
<h3 class="anchored" data-anchor-id="architecture-logicielle">1.3 Architecture Logicielle</h3>
<p>La classe <code>VARCLUS</code> hérite de la classe abstraite <code>ClusterAnalysis</code> et implémente une architecture R6 garantissant l’encapsulation des données et la traçabilité du processus de partitionnement. L’arbre de division est stocké sous forme de structure récursive, permettant une exploration flexible des résultats à différents niveaux de granularité.</p>
</section>
</section>
<section id="traduction-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="traduction-algorithmique">2. Traduction Algorithmique</h2>
<section id="phase-dinitialisation" class="level3">
<h3 class="anchored" data-anchor-id="phase-dinitialisation">2.1 Phase d’Initialisation</h3>
<section id="validation-et-préparation-des-données" class="level4">
<h4 class="anchored" data-anchor-id="validation-et-préparation-des-données">Validation et Préparation des Données</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> private<span class="sc">$</span><span class="fu">validateDataset</span>(X)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FX <span class="ot">&lt;-</span> X</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">ncol</span>(X) <span class="sc">&lt;</span> <span class="dv">3</span>) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stop</span>(<span class="st">"VARCLUS nécessite au moins 3 variables"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La méthode héritée <code>validateDataset()</code> assure la conformité du jeu de données, incluant la vérification du type des variables et le traitement des observations incomplètes. La condition minimale de trois variables découle de la nécessité d’avoir au moins deux composantes principales distinctes pour effectuer une bipartition significative.</p>
</section>
<section id="paramètres-de-contrôle" class="level4">
<h4 class="anchored" data-anchor-id="paramètres-de-contrôle">Paramètres de Contrôle</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FStopEigenvalue <span class="ot">&lt;-</span> stop_eigenvalue  <span class="co"># Seuil λ₂ (défaut: 1.0)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FDistanceMetric <span class="ot">&lt;-</span> distance_metric   <span class="co"># Métrique de dissimilarité</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le paramètre <code>stop_eigenvalue</code> définit le critère d’arrêt basé sur la seconde valeur propre. Une valeur de 1.0 (défaut) correspond à un critère statistique standard : on arrête la division lorsque la variance expliquée par la seconde composante devient inférieure à celle d’une variable aléatoire standardisée.</p>
</section>
</section>
<section id="algorithme-de-division-récursive" class="level3">
<h3 class="anchored" data-anchor-id="algorithme-de-division-récursive">2.2 Algorithme de Division Récursive</h3>
<section id="pseudo-code-formel" class="level4">
<h4 class="anchored" data-anchor-id="pseudo-code-formel">Pseudo-Code Formel</h4>
<pre><code>ALGORITHME: recursive_split(vars, depth)
ENTRÉE: 
  - vars: indices des variables du groupe à traiter
  - depth: profondeur actuelle dans l'arbre
SORTIE: 
  - Structure arborescente (nœud ou feuille)

1. SI |vars| &lt; 3 ALORS
     RETOURNER feuille(vars, depth)
   FIN SI

2. X_sub ← FX[, vars]
   pca_result ← ACP(X_sub, standardisé = VRAI)
   λ₁, λ₂ ← deux premières valeurs propres

3. SI λ₂ &lt; seuil_arrêt ALORS
     RETOURNER feuille(vars, depth, λ₁, λ₂)
   FIN SI

4. loadings_rotated ← VARIMAX(pca_result$rotation[, 1:2])

5. POUR CHAQUE variable i DANS vars FAIRE
     SI |loadings[i, 1]| ≥ |loadings[i, 2]| ALORS
        groupe1 ← groupe1 ∪ {i}
     SINON
        groupe2 ← groupe2 ∪ {i}
     FIN SI
   FIN POUR

6. branche_gauche ← recursive_split(groupe1, depth + 1)
   branche_droite ← recursive_split(groupe2, depth + 1)

7. RETOURNER nœud(depth, λ₁, λ₂, branche_gauche, branche_droite)</code></pre>
</section>
<section id="implémentation-r6" class="level4">
<h4 class="anchored" data-anchor-id="implémentation-r6">Implémentation R6</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>recursive_split <span class="ot">=</span> <span class="cf">function</span>(vars, <span class="at">depth =</span> <span class="dv">0</span>) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  n_vars <span class="ot">&lt;-</span> <span class="fu">length</span>(vars)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Critère d'arrêt : cardinalité minimale</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (n_vars <span class="sc">&lt;</span> <span class="dv">3</span>) {</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      <span class="at">type =</span> <span class="st">"leaf"</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">vars =</span> vars,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">depth =</span> depth</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ACP sur le sous-groupe de variables</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  X_sub <span class="ot">&lt;-</span> private<span class="sc">$</span>FX[, vars, drop <span class="ot">=</span> <span class="cn">FALSE</span>]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  pca_result <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(X_sub, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">center =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Récupérer les 2 premières valeurs propres</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  eigenvalues <span class="ot">&lt;-</span> pca_result<span class="sc">$</span>sdev<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  lambda1 <span class="ot">&lt;-</span> eigenvalues[<span class="dv">1</span>]</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  lambda2 <span class="ot">&lt;-</span> <span class="cf">if</span>(<span class="fu">length</span>(eigenvalues) <span class="sc">&gt;=</span> <span class="dv">2</span>) eigenvalues[<span class="dv">2</span>] <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Critère d'arrêt : seconde valeur propre insuffisante</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (lambda2 <span class="sc">&lt;</span> private<span class="sc">$</span>FStopEigenvalue) {</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>      <span class="at">type =</span> <span class="st">"leaf"</span>,</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>      <span class="at">vars =</span> vars,</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>      <span class="at">depth =</span> depth,</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>      <span class="at">lambda1 =</span> lambda1,</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>      <span class="at">lambda2 =</span> lambda2</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Rotation Varimax sur les 2 premiers axes</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">ncol</span>(pca_result<span class="sc">$</span>rotation) <span class="sc">&gt;=</span> <span class="dv">2</span>) {</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    rotated <span class="ot">&lt;-</span> <span class="fu">varimax</span>(pca_result<span class="sc">$</span>rotation[, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>])</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    loadings <span class="ot">&lt;-</span> rotated<span class="sc">$</span>loadings</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    loadings <span class="ot">&lt;-</span> pca_result<span class="sc">$</span>rotation[, <span class="dv">1</span>, drop <span class="ot">=</span> <span class="cn">FALSE</span>]</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Partitionnement par proximité maximale</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>  axis1_corr <span class="ot">&lt;-</span> <span class="fu">abs</span>(loadings[, <span class="dv">1</span>])</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>  axis2_corr <span class="ot">&lt;-</span> <span class="cf">if</span>(<span class="fu">ncol</span>(loadings) <span class="sc">&gt;=</span> <span class="dv">2</span>) <span class="fu">abs</span>(loadings[, <span class="dv">2</span>]) <span class="cf">else</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">nrow</span>(loadings))</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>  group1_idx <span class="ot">&lt;-</span> <span class="fu">which</span>(axis1_corr <span class="sc">&gt;=</span> axis2_corr)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>  group2_idx <span class="ot">&lt;-</span> <span class="fu">which</span>(axis1_corr <span class="sc">&lt;</span> axis2_corr)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Appels récursifs</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>  left_branch <span class="ot">&lt;-</span> private<span class="sc">$</span><span class="fu">recursive_split</span>(vars[group1_idx], depth <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>  right_branch <span class="ot">&lt;-</span> private<span class="sc">$</span><span class="fu">recursive_split</span>(vars[group2_idx], depth <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"node"</span>,</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    <span class="at">depth =</span> depth,</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span class="at">lambda1 =</span> lambda1,</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    <span class="at">lambda2 =</span> lambda2,</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="at">left =</span> left_branch,</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>    <span class="at">right =</span> right_branch</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="critères-darrêt" class="level3">
<h3 class="anchored" data-anchor-id="critères-darrêt">2.3 Critères d’Arrêt</h3>
<section id="critère-de-cardinalité-minimale" class="level4">
<h4 class="anchored" data-anchor-id="critère-de-cardinalité-minimale">Critère de Cardinalité Minimale</h4>
<p>La condition <span class="math inline">\(|V| &lt; 3\)</span> (où <span class="math inline">\(V\)</span> désigne l’ensemble de variables à partitionner) constitue un critère d’arrêt structural : avec moins de trois variables, l’ACP ne peut produire deux composantes principales distinctes permettant une bipartition informative.</p>
</section>
<section id="critère-de-significativité-de-la-seconde-valeur-propre" class="level4">
<h4 class="anchored" data-anchor-id="critère-de-significativité-de-la-seconde-valeur-propre">Critère de Significativité de la Seconde Valeur Propre</h4>
<p>Le critère <span class="math inline">\(\lambda_2 &lt; \tau\)</span> (où <span class="math inline">\(\tau\)</span> est le seuil, typiquement fixé à 1.0) repose sur une justification statistique :</p>
<p><span class="math display">\[\lambda_2 \geq 1 \Leftrightarrow \text{La seconde dimension explique au moins autant de variance qu'une variable standardisée}\]</span></p>
<p>Lorsque <span class="math inline">\(\lambda_2 &lt; 1\)</span>, cela indique que la structure de corrélation est essentiellement unidimensionnelle, et qu’une division supplémentaire n’apporterait pas d’amélioration substantielle de l’homogénéité intra-groupe.</p>
<p>Mathématiquement, pour un ensemble de <span class="math inline">\(p\)</span> variables standardisées :</p>
<p><span class="math display">\[\sum_{i=1}^{p} \lambda_i = p\]</span></p>
<p>Le critère <span class="math inline">\(\lambda_2 \geq 1\)</span> signifie que la seconde composante capture une part non négligeable (≥ 1/p) de la variance totale.</p>
</section>
</section>
<section id="rotation-varimax" class="level3">
<h3 class="anchored" data-anchor-id="rotation-varimax">2.4 Rotation Varimax</h3>
<section id="principe-et-justification" class="level4">
<h4 class="anchored" data-anchor-id="principe-et-justification">Principe et Justification</h4>
<p>La rotation Varimax est une transformation orthogonale appliquée aux deux premières composantes principales afin de simplifier la structure des contributions (loadings) des variables sur ces axes. L’objectif est de maximiser la variance des carrés des contributions, favorisant ainsi une interprétation plus claire où chaque variable présente une forte contribution sur un axe et une faible contribution sur l’autre.</p>
<p>Formellement, la rotation Varimax résout le problème d’optimisation :</p>
<p><span class="math display">\[\max_{Q \in O(2)} \sum_{j=1}^{2} \text{Var}\left((L Q)_{:,j}^2\right)\]</span></p>
<p>où <span class="math inline">\(L\)</span> est la matrice des loadings originaux et <span class="math inline">\(Q\)</span> une matrice de rotation orthogonale 2×2.</p>
</section>
<section id="implémentation" class="level4">
<h4 class="anchored" data-anchor-id="implémentation">Implémentation</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">ncol</span>(pca_result<span class="sc">$</span>rotation) <span class="sc">&gt;=</span> <span class="dv">2</span>) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  rotated <span class="ot">&lt;-</span> <span class="fu">varimax</span>(pca_result<span class="sc">$</span>rotation[, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  loadings <span class="ot">&lt;-</span> rotated<span class="sc">$</span>loadings</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette transformation préserve les propriétés métriques (angles, distances) tout en améliorant la séparabilité des variables dans l’espace factoriel bidimensionnel.</p>
</section>
</section>
<section id="règle-de-bipartition" class="level3">
<h3 class="anchored" data-anchor-id="règle-de-bipartition">2.5 Règle de Bipartition</h3>
<section id="assignation-par-proximité-maximale" class="level4">
<h4 class="anchored" data-anchor-id="assignation-par-proximité-maximale">Assignation par Proximité Maximale</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>axis1_corr <span class="ot">&lt;-</span> <span class="fu">abs</span>(loadings[, <span class="dv">1</span>])</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>axis2_corr <span class="ot">&lt;-</span> <span class="cf">if</span>(<span class="fu">ncol</span>(loadings) <span class="sc">&gt;=</span> <span class="dv">2</span>) <span class="fu">abs</span>(loadings[, <span class="dv">2</span>]) <span class="cf">else</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">nrow</span>(loadings))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>group1_idx <span class="ot">&lt;-</span> <span class="fu">which</span>(axis1_corr <span class="sc">&gt;=</span> axis2_corr)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>group2_idx <span class="ot">&lt;-</span> <span class="fu">which</span>(axis1_corr <span class="sc">&lt;</span> axis2_corr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Chaque variable <span class="math inline">\(X_i\)</span> est assignée au groupe correspondant à l’axe factoriel avec lequel elle présente la corrélation absolue la plus élevée :</p>
<p><span class="math display">\[\text{Groupe}(X_i) = \begin{cases}
G_1 &amp; \text{si } |a_{i1}| \geq |a_{i2}| \\
G_2 &amp; \text{si } |a_{i1}| &lt; |a_{i2}|
\end{cases}\]</span></p>
<p>où <span class="math inline">\(a_{i1}\)</span> et <span class="math inline">\(a_{i2}\)</span> sont les loadings de la variable <span class="math inline">\(X_i\)</span> sur les deux axes rotatés.</p>
<p>Cette règle garantit une partition exhaustive et exclusive : chaque variable appartient à exactement un groupe, et la bipartition maximise localement la cohérence interne de chaque sous-groupe.</p>
</section>
</section>
<section id="extraction-de-la-partition-finale" class="level3">
<h3 class="anchored" data-anchor-id="extraction-de-la-partition-finale">2.6 Extraction de la Partition Finale</h3>
<section id="parcours-de-larbre-en-profondeur" class="level4">
<h4 class="anchored" data-anchor-id="parcours-de-larbre-en-profondeur">Parcours de l’Arbre en Profondeur</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>extract_clusters <span class="ot">=</span> <span class="cf">function</span>(tree, <span class="at">cluster_id =</span> <span class="dv">1</span>) {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (tree<span class="sc">$</span>type <span class="sc">==</span> <span class="st">"leaf"</span>) {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (var <span class="cf">in</span> tree<span class="sc">$</span>vars) {</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      private<span class="sc">$</span>FGroupes[var] <span class="ot">&lt;-</span> cluster_id</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(cluster_id <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    cluster_id <span class="ot">&lt;-</span> private<span class="sc">$</span><span class="fu">extract_clusters</span>(tree<span class="sc">$</span>left, cluster_id)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    cluster_id <span class="ot">&lt;-</span> private<span class="sc">$</span><span class="fu">extract_clusters</span>(tree<span class="sc">$</span>right, cluster_id)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(cluster_id)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Une fois l’arbre de division construit, les clusters finaux correspondent aux feuilles de cet arbre. Un parcours en profondeur (depth-first search) permet d’assigner à chaque variable un identifiant de cluster unique, tout en préservant l’ordre hiérarchique des divisions.</p>
<p>L’algorithme maintient un compteur <code>cluster_id</code> qui s’incrémente à chaque feuille visitée, garantissant ainsi une numérotation séquentielle des groupes finaux.</p>
</section>
</section>
</section>
<section id="fondements-mathématiques" class="level2">
<h2 class="anchored" data-anchor-id="fondements-mathématiques">3. Fondements Mathématiques</h2>
<section id="analyse-en-composantes-principales-acp" class="level3">
<h3 class="anchored" data-anchor-id="analyse-en-composantes-principales-acp">3.1 Analyse en Composantes Principales (ACP)</h3>
<section id="décomposition-spectrale" class="level4">
<h4 class="anchored" data-anchor-id="décomposition-spectrale">Décomposition Spectrale</h4>
<p>L’ACP sur un ensemble de <span class="math inline">\(p\)</span> variables standardisées <span class="math inline">\(\mathbf{X} = [X_1, \ldots, X_p]\)</span> consiste à diagonaliser la matrice de corrélation <span class="math inline">\(\mathbf{R} = \text{Cor}(\mathbf{X})\)</span> :</p>
<p><span class="math display">\[\mathbf{R} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^T\]</span></p>
<p>où <span class="math inline">\(\mathbf{\Lambda} = \text{diag}(\lambda_1, \ldots, \lambda_p)\)</span> avec <span class="math inline">\(\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_p \geq 0\)</span> et <span class="math inline">\(\mathbf{V}\)</span> est la matrice orthonormale des vecteurs propres.</p>
<p>Les composantes principales sont définies par :</p>
<p><span class="math display">\[\mathbf{Z} = \mathbf{X} \mathbf{V}\]</span></p>
<p>La variance expliquée par la <span class="math inline">\(k\)</span>-ième composante est :</p>
<p><span class="math display">\[\frac{\lambda_k}{\sum_{i=1}^{p} \lambda_i} = \frac{\lambda_k}{p}\]</span></p>
</section>
</section>
<section id="optimalité-de-la-rotation-varimax" class="level3">
<h3 class="anchored" data-anchor-id="optimalité-de-la-rotation-varimax">3.2 Optimalité de la Rotation Varimax</h3>
<section id="critère-de-kaiser" class="level4">
<h4 class="anchored" data-anchor-id="critère-de-kaiser">Critère de Kaiser</h4>
<p>La rotation Varimax maximise le critère de simplicité de Kaiser :</p>
<p><span class="math display">\[V = \sum_{j=1}^{2} \left[ \frac{1}{p} \sum_{i=1}^{p} a_{ij}^4 - \left( \frac{1}{p} \sum_{i=1}^{p} a_{ij}^2 \right)^2 \right]\]</span></p>
<p>où <span class="math inline">\(a_{ij}\)</span> désigne le loading de la variable <span class="math inline">\(i\)</span> sur l’axe <span class="math inline">\(j\)</span> après rotation.</p>
<p>Cette formulation équivaut à maximiser la variance des contributions au carré, ce qui favorise une structure où chaque variable est principalement associée à un seul axe factoriel.</p>
</section>
</section>
<section id="propriétés-de-la-bipartition" class="level3">
<h3 class="anchored" data-anchor-id="propriétés-de-la-bipartition">3.3 Propriétés de la Bipartition</h3>
<section id="inertie-intra-groupe-et-inter-groupe" class="level4">
<h4 class="anchored" data-anchor-id="inertie-intra-groupe-et-inter-groupe">Inertie Intra-Groupe et Inter-Groupe</h4>
<p>Soit <span class="math inline">\(G_1\)</span> et <span class="math inline">\(G_2\)</span> les deux groupes produits par la bipartition. L’inertie totale d’un ensemble de variables se décompose selon le théorème de Huygens généralisé :</p>
<p><span class="math display">\[I_{\text{totale}} = I_{\text{intra}}(G_1) + I_{\text{intra}}(G_2) + I_{\text{inter}}(G_1, G_2)\]</span></p>
<p>où : - <span class="math inline">\(I_{\text{intra}}(G_k)\)</span> mesure la dispersion des variables au sein du groupe <span class="math inline">\(G_k\)</span> - <span class="math inline">\(I_{\text{inter}}(G_1, G_2)\)</span> quantifie la séparation entre les deux groupes</p>
<p>La stratégie de partitionnement de VARCLUS vise implicitement à minimiser l’inertie intra-groupe (ou, de manière équivalente, à maximiser l’inertie inter-groupe).</p>
</section>
</section>
<section id="complexité-algorithmique" class="level3">
<h3 class="anchored" data-anchor-id="complexité-algorithmique">3.4 Complexité Algorithmique</h3>
<section id="complexité-temporelle" class="level4">
<h4 class="anchored" data-anchor-id="complexité-temporelle">Complexité Temporelle</h4>
<p>Pour un ensemble de <span class="math inline">\(p\)</span> variables et <span class="math inline">\(n\)</span> observations :</p>
<ol type="1">
<li><strong>ACP par sous-groupe</strong> : <span class="math inline">\(O(p^2 n + p^3)\)</span> dans le pire cas (dominé par le calcul de la matrice de covariance et sa diagonalisation)</li>
<li><strong>Rotation Varimax</strong> : <span class="math inline">\(O(p)\)</span> (transformation 2D, complexité négligeable)</li>
<li><strong>Bipartition</strong> : <span class="math inline">\(O(p)\)</span> (parcours linéaire des loadings)</li>
</ol>
<p>Dans le cas d’une division équilibrée (chaque nœud se partitionne en deux groupes de taille similaire), la profondeur de l’arbre est <span class="math inline">\(O(\log p)\)</span>. La complexité totale est donc :</p>
<p><span class="math display">\[T(p, n) = O(p^2 n \log p + p^3 \log p)\]</span></p>
<p>Pour <span class="math inline">\(n \gg p\)</span> (cas fréquent en pratique), on a <span class="math inline">\(T(p, n) \approx O(p^2 n \log p)\)</span>.</p>
</section>
<section id="complexité-spatiale" class="level4">
<h4 class="anchored" data-anchor-id="complexité-spatiale">Complexité Spatiale</h4>
<p>L’arbre de partition nécessite un espace mémoire <span class="math inline">\(O(p)\)</span> pour stocker les nœuds internes et les feuilles. Les données intermédiaires (matrices ACP) sont recalculées à chaque niveau et ne persistent pas, limitant ainsi l’empreinte mémoire.</p>
</section>
</section>
</section>
<section id="comparaison-avec-les-approches-alternatives" class="level2">
<h2 class="anchored" data-anchor-id="comparaison-avec-les-approches-alternatives">4. Comparaison avec les Approches Alternatives</h2>
<section id="varclus-vs.-cah-ascendante-var-cah" class="level3">
<h3 class="anchored" data-anchor-id="varclus-vs.-cah-ascendante-var-cah">4.1 VARCLUS vs.&nbsp;CAH Ascendante (VAR-CAH)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 42%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Critère</th>
<th>VARCLUS (Descendant)</th>
<th>VAR-CAH (Ascendant)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Stratégie</strong></td>
<td>Division récursive top-down</td>
<td>Fusion progressive bottom-up</td>
</tr>
<tr class="even">
<td><strong>Complexité</strong></td>
<td><span class="math inline">\(O(p^2 n \log p)\)</span></td>
<td><span class="math inline">\(O(p^2 n + p^2 \log p)\)</span></td>
</tr>
<tr class="odd">
<td><strong>Critère d’arrêt</strong></td>
<td>Statistique (<span class="math inline">\(\lambda_2 &lt; 1\)</span>)</td>
<td>Heuristique (coude, gap)</td>
</tr>
<tr class="even">
<td><strong>Optimalité locale</strong></td>
<td>À chaque division</td>
<td>À chaque fusion</td>
</tr>
<tr class="odd">
<td><strong>Interprétabilité</strong></td>
<td>Structure arborescente binaire</td>
<td>Dendrogramme complet</td>
</tr>
<tr class="even">
<td><strong>Déterminisme</strong></td>
<td>Oui (division unique)</td>
<td>Oui (fusion unique)</td>
</tr>
<tr class="odd">
<td><strong>Nombre de clusters</strong></td>
<td>Détection automatique</td>
<td>Spécification ou coupe</td>
</tr>
</tbody>
</table>
<section id="avantages-de-varclus" class="level4">
<h4 class="anchored" data-anchor-id="avantages-de-varclus">Avantages de VARCLUS</h4>
<ol type="1">
<li><strong>Critère d’arrêt objectif</strong> : Le seuil <span class="math inline">\(\lambda_2 \geq 1\)</span> a une interprétation statistique claire</li>
<li><strong>Efficacité computationnelle</strong> : Complexité logarithmique en <span class="math inline">\(p\)</span> plutôt que quadratique</li>
<li><strong>Stabilité sur grandes dimensions</strong> : Moins sensible au nombre total de variables</li>
</ol>
</section>
<section id="limitations-de-varclus" class="level4">
<h4 class="anchored" data-anchor-id="limitations-de-varclus">Limitations de VARCLUS</h4>
<ol type="1">
<li><strong>Partition binaire stricte</strong> : La bipartition peut être sous-optimale si la structure naturelle est non binaire</li>
<li><strong>Sensibilité à l’ordre de division</strong> : Les premières divisions contraignent les suivantes (approche gloutonne)</li>
<li><strong>Pas de réallocation</strong> : Une fois assignée, une variable ne peut plus changer de groupe</li>
</ol>
</section>
</section>
<section id="varclus-vs.-k-modes-de-variables" class="level3">
<h3 class="anchored" data-anchor-id="varclus-vs.-k-modes-de-variables">4.2 VARCLUS vs.&nbsp;K-Modes de Variables</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Critère</th>
<th>VARCLUS</th>
<th>K-Modes Variables</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Nature des variables</strong></td>
<td>Quantitatives</td>
<td>Catégorielles</td>
</tr>
<tr class="even">
<td><strong>Métrique</strong></td>
<td>Corrélation (via ACP)</td>
<td>Désaccord simple</td>
</tr>
<tr class="odd">
<td><strong>Initialisation</strong></td>
<td>Déterministe</td>
<td>Aléatoire (centroïdes)</td>
</tr>
<tr class="even">
<td><strong>Itérations</strong></td>
<td>Une passe (récursive)</td>
<td>Multiples (réallocation)</td>
</tr>
<tr class="odd">
<td><strong>Convergence</strong></td>
<td>Garantie (terminaison)</td>
<td>Locale (peut diverger)</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="cas-dusage-et-applications" class="level2">
<h2 class="anchored" data-anchor-id="cas-dusage-et-applications">5. Cas d’Usage et Applications</h2>
<section id="prétraitement-pour-modélisation-statistique" class="level3">
<h3 class="anchored" data-anchor-id="prétraitement-pour-modélisation-statistique">5.1 Prétraitement pour Modélisation Statistique</h3>
<p>Dans des contextes de régression ou classification avec un grand nombre de prédicteurs corrélés, VARCLUS permet d’identifier des groupes de variables redondantes. Un représentant (ou une variable synthétique via ACP) peut ensuite être sélectionné par groupe, réduisant ainsi la multicolinéarité.</p>
<p><strong>Exemple</strong> : En génomique, pour analyser l’expression de milliers de gènes, VARCLUS identifie des modules co-régulés avant sélection de gènes marqueurs.</p>
</section>
<section id="construction-de-scores-synthétiques" class="level3">
<h3 class="anchored" data-anchor-id="construction-de-scores-synthétiques">5.2 Construction de Scores Synthétiques</h3>
<p>VARCLUS facilite la création d’indices composites en regroupant des indicateurs mesurant des construits latents similaires. Chaque cluster peut être synthétisé en un score unidimensionnel via sa première composante principale.</p>
<p><strong>Exemple</strong> : En psychométrie, pour construire un indice de satisfaction client à partir de multiples items de questionnaire.</p>
</section>
<section id="exploration-de-structures-de-données-complexes" class="level3">
<h3 class="anchored" data-anchor-id="exploration-de-structures-de-données-complexes">5.3 Exploration de Structures de Données Complexes</h3>
<p>L’arbre de partition produit par VARCLUS offre une représentation hiérarchique des relations entre variables, utile pour l’exploration de jeux de données multi-dimensionnels.</p>
<p><strong>Exemple</strong> : En finance quantitative, pour comprendre les co-mouvements entre actifs financiers et identifier des secteurs d’investissement cohérents.</p>
</section>
<section id="détection-de-redondance-informationnelle" class="level3">
<h3 class="anchored" data-anchor-id="détection-de-redondance-informationnelle">5.4 Détection de Redondance Informationnelle</h3>
<p>En identifiant des variables fortement corrélées, VARCLUS aide à détecter les redondances dans la collecte de données, permettant de réduire les coûts opérationnels.</p>
<p><strong>Exemple</strong> : En télédétection spatiale, pour éliminer des bandes spectrales redondantes dans l’analyse d’images satellites.</p>
</section>
</section>
<section id="extensions-et-perspectives" class="level2">
<h2 class="anchored" data-anchor-id="extensions-et-perspectives">6. Extensions et Perspectives</h2>
<section id="variantes-algorithmiques" class="level3">
<h3 class="anchored" data-anchor-id="variantes-algorithmiques">6.1 Variantes Algorithmiques</h3>
<section id="varclus-avec-réallocation" class="level4">
<h4 class="anchored" data-anchor-id="varclus-avec-réallocation">VARCLUS avec Réallocation</h4>
<p>Une extension possible consiste à alterner les divisions descendantes avec des phases de réallocation itérative des variables entre clusters, à la manière de l’algorithme K-means. Cela permettrait de corriger les assignations sous-optimales dues à la nature gloutonne de l’approche purement descendante.</p>
</section>
<section id="varclus-non-binaire" class="level4">
<h4 class="anchored" data-anchor-id="varclus-non-binaire">VARCLUS Non-Binaire</h4>
<p>Plutôt que de forcer une bipartition à chaque nœud, on pourrait généraliser à une k-partition (<span class="math inline">\(k &gt; 2\)</span>) en extrayant plus de deux composantes principales et en appliquant un clustering (K-means) dans l’espace factoriel réduit.</p>
</section>
</section>
<section id="adaptation-aux-variables-mixtes" class="level3">
<h3 class="anchored" data-anchor-id="adaptation-aux-variables-mixtes">6.2 Adaptation aux Variables Mixtes</h3>
<section id="approche-pcamix" class="level4">
<h4 class="anchored" data-anchor-id="approche-pcamix">Approche PCAMIX</h4>
<p>L’intégration de l’analyse factorielle pour données mixtes (PCAMIX) permettrait d’étendre VARCLUS aux jeux de données comportant à la fois des variables quantitatives et qualitatives. La matrice de corrélation serait remplacée par une matrice de proximité généralisée.</p>
</section>
<section id="métrique-de-gower" class="level4">
<h4 class="anchored" data-anchor-id="métrique-de-gower">Métrique de Gower</h4>
<p>Une alternative consiste à utiliser la distance de Gower pour mesurer la dissimilarité entre variables de types hétérogènes, puis à adapter le critère de bipartition en conséquence.</p>
</section>
</section>
<section id="robustification" class="level3">
<h3 class="anchored" data-anchor-id="robustification">6.3 Robustification</h3>
<section id="acp-robuste" class="level4">
<h4 class="anchored" data-anchor-id="acp-robuste">ACP Robuste</h4>
<p>L’utilisation d’estimateurs robustes de la matrice de covariance (ex. : estimateur de minimum volume de covariance, MCD) rendrait VARCLUS moins sensible aux observations aberrantes.</p>
</section>
<section id="corrélations-de-rang" class="level4">
<h4 class="anchored" data-anchor-id="corrélations-de-rang">Corrélations de Rang</h4>
<p>Le remplacement de la corrélation de Pearson par des mesures de dépendance non-paramétriques (Spearman, Kendall) permettrait de capturer des relations monotones non linéaires.</p>
</section>
</section>
<section id="critères-darrêt-alternatifs" class="level3">
<h3 class="anchored" data-anchor-id="critères-darrêt-alternatifs">6.4 Critères d’Arrêt Alternatifs</h3>
<section id="bootstrap-gap-statistic" class="level4">
<h4 class="anchored" data-anchor-id="bootstrap-gap-statistic">Bootstrap Gap Statistic</h4>
<p>Au lieu du critère <span class="math inline">\(\lambda_2 \geq 1\)</span>, on pourrait utiliser la gap statistic, qui compare la dispersion intra-groupe observée à celle obtenue sur des données de référence générées aléatoirement.</p>
</section>
<section id="critère-dinformation-bayésien-bic" class="level4">
<h4 class="anchored" data-anchor-id="critère-dinformation-bayésien-bic">Critère d’Information Bayésien (BIC)</h4>
<p>Un critère de type BIC pourrait être défini pour pénaliser la complexité du modèle (nombre de clusters) tout en récompensant la qualité de l’ajustement.</p>
</section>
</section>
</section>
<section id="limitations-actuelles" class="level2">
<h2 class="anchored" data-anchor-id="limitations-actuelles">7. Limitations Actuelles</h2>
<section id="contrainte-de-bipartition" class="level3">
<h3 class="anchored" data-anchor-id="contrainte-de-bipartition">7.1 Contrainte de Bipartition</h3>
<p>La structure binaire imposée peut ne pas refléter la structure naturelle des données. Si un ensemble de variables se décompose naturellement en trois groupes, VARCLUS produira une partition sous-optimale avec des divisions supplémentaires.</p>
</section>
<section id="absence-de-réallocation" class="level3">
<h3 class="anchored" data-anchor-id="absence-de-réallocation">7.2 Absence de Réallocation</h3>
<p>Une fois qu’une division est effectuée, les variables ne peuvent plus être transférées entre branches de l’arbre. Cette rigidité peut conduire à des partitions localement sous-optimales.</p>
</section>
<section id="variables-quantitatives-uniquement" class="level3">
<h3 class="anchored" data-anchor-id="variables-quantitatives-uniquement">7.3 Variables Quantitatives Uniquement</h3>
<p>Dans l’implémentation actuelle, seules les variables numériques continues sont supportées. Les variables catégorielles ou ordinales nécessitent des transformations préalables ou l’utilisation de méthodes alternatives (K-Modes).</p>
</section>
<section id="sensibilité-au-seuil-darrêt" class="level3">
<h3 class="anchored" data-anchor-id="sensibilité-au-seuil-darrêt">7.4 Sensibilité au Seuil d’Arrêt</h3>
<p>Le choix du paramètre <code>stop_eigenvalue</code> influence directement le nombre de clusters finaux. Bien que la valeur par défaut de 1.0 soit théoriquement justifiée, elle peut ne pas être optimale pour tous les contextes applicatifs.</p>
</section>
</section>
<section id="implémentation-et-bonnes-pratiques" class="level2">
<h2 class="anchored" data-anchor-id="implémentation-et-bonnes-pratiques">8. Implémentation et Bonnes Pratiques</h2>
<section id="standardisation-des-variables" class="level3">
<h3 class="anchored" data-anchor-id="standardisation-des-variables">8.1 Standardisation des Variables</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>pca_result <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(X_sub, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">center =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La standardisation (centrage et réduction) est cruciale pour garantir que toutes les variables contribuent équitablement à l’ACP, indépendamment de leurs échelles de mesure respectives.</p>
</section>
<section id="gestion-des-valeurs-manquantes" class="level3">
<h3 class="anchored" data-anchor-id="gestion-des-valeurs-manquantes">8.2 Gestion des Valeurs Manquantes</h3>
<p>L’implémentation actuelle s’appuie sur la méthode héritée <code>validateDataset()</code> qui traite les données manquantes selon la stratégie définie (<code>na_action</code>). Pour VARCLUS, il est recommandé de : - Utiliser l’imputation préalable si le taux de données manquantes est modéré (&lt; 20%) - Supprimer les variables avec trop de valeurs manquantes (&gt; 50%) - Documenter explicitement la stratégie adoptée dans le pipeline analytique</p>
</section>
<section id="interprétation-des-résultats" class="level3">
<h3 class="anchored" data-anchor-id="interprétation-des-résultats">8.3 Interprétation des Résultats</h3>
<section id="inspection-de-larbre" class="level4">
<h4 class="anchored" data-anchor-id="inspection-de-larbre">Inspection de l’Arbre</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>varclus_model <span class="ot">&lt;-</span> VARCLUS<span class="sc">$</span><span class="fu">new</span>(<span class="at">stop_eigenvalue =</span> <span class="fl">1.0</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>varclus_model<span class="sc">$</span><span class="fu">fit</span>(X)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">&lt;-</span> varclus_model<span class="sc">$</span>FTree  <span class="co"># Structure interne de l'arbre</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>L’arbre de partition peut être visualisé ou exporté pour analyse. Les valeurs <span class="math inline">\(\lambda_1\)</span> et <span class="math inline">\(\lambda_2\)</span> à chaque nœud renseignent sur la qualité de la division.</p>
</section>
<section id="diagnostic-de-stabilité" class="level4">
<h4 class="anchored" data-anchor-id="diagnostic-de-stabilité">Diagnostic de Stabilité</h4>
<p>Il est recommandé de : - Évaluer la sensibilité au seuil d’arrêt en testant plusieurs valeurs (ex. : 0.7, 1.0, 1.5) - Comparer les résultats avec une approche ascendante (VAR-CAH) pour vérifier la cohérence - Analyser la distribution des tailles de clusters (déséquilibres extrêmes peuvent signaler un problème)</p>
</section>
</section>
</section>
<section id="références-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="références-théoriques">9. Références Théoriques</h2>
<p>L’algorithme VARCLUS s’inspire des travaux fondateurs suivants :</p>
<section id="références-primaires" class="level3">
<h3 class="anchored" data-anchor-id="références-primaires">9.1 Références Primaires</h3>
<ul>
<li><p><strong>SAS Institute Inc.&nbsp;(1990)</strong> : <em>SAS/STAT User’s Guide, Volume 2</em>, Cary, NC: SAS Institute Inc.<br>
Description originale de la procédure PROC VARCLUS dans le logiciel SAS, formalisant l’algorithme de division récursive avec critère <span class="math inline">\(\lambda_2 \geq 1\)</span>.</p></li>
<li><p><strong>Sarle, W.S. (1990)</strong> : <em>“The VARCLUS Procedure”</em>, in <em>SAS/STAT User’s Guide, Version 6</em>, Fourth Edition, Volume 2, pp.&nbsp;1641-1659.<br>
Présentation détaillée des fondements algorithmiques et des justifications statistiques.</p></li>
</ul>
</section>
<section id="fondements-théoriques-1" class="level3">
<h3 class="anchored" data-anchor-id="fondements-théoriques-1">9.2 Fondements Théoriques</h3>
<ul>
<li><p><strong>Kaiser, H.F. (1958)</strong> : <em>“The varimax criterion for analytic rotation in factor analysis”</em>, Psychometrika, 23(3), 187-200.<br>
Formalisation mathématique de la rotation Varimax utilisée dans VARCLUS pour simplifier la structure factorielle.</p></li>
<li><p><strong>Jolliffe, I.T. (2002)</strong> : <em>Principal Component Analysis</em>, Second Edition, Springer Series in Statistics.<br>
Référence standard pour les fondements mathématiques de l’ACP.</p></li>
</ul>
</section>
<section id="méthodes-apparentées" class="level3">
<h3 class="anchored" data-anchor-id="méthodes-apparentées">9.3 Méthodes Apparentées</h3>
<ul>
<li><p><strong>Chavent, M., Kuentz-Simonet, V., Liquet, B., &amp; Saracco, J. (2012)</strong> : <em>“ClustOfVar: An R Package for the Clustering of Variables”</em>, Journal of Statistical Software, 50(13), 1-16.<br>
Description de l’approche ascendante complémentaire (VAR-CAH).</p></li>
<li><p><strong>Vigneau, E., &amp; Qannari, E.M. (2003)</strong> : <em>“Clustering of variables around latent components”</em>, Communications in Statistics - Simulation and Computation, 32(4), 1131-1150.<br>
Fondements théoriques du clustering de variables par composantes latentes.</p></li>
</ul>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">10. Conclusion</h2>
<section id="positionnement-méthodologique" class="level3">
<h3 class="anchored" data-anchor-id="positionnement-méthodologique">10.1 Positionnement Méthodologique</h3>
<p>VARCLUS constitue une alternative performante aux méthodes ascendantes pour le clustering de variables, particulièrement adaptée aux jeux de données de grande dimension où l’efficacité computationnelle est critique. Son critère d’arrêt statistiquement fondé (<span class="math inline">\(\lambda_2 \geq 1\)</span>) offre une objectivité appréciable, réduisant l’arbitraire du choix du nombre de clusters.</p>
</section>
<section id="complémentarité-avec-var-cah" class="level3">
<h3 class="anchored" data-anchor-id="complémentarité-avec-var-cah">10.2 Complémentarité avec VAR-CAH</h3>
<p>L’utilisation conjointe de VARCLUS (descendant) et VAR-CAH (ascendant) sur un même jeu de données permet de valider la robustesse de la structure identifiée. Une convergence des deux approches vers des partitions similaires renforce la confiance dans les résultats.</p>
</section>
<section id="recommandations-pratiques" class="level3">
<h3 class="anchored" data-anchor-id="recommandations-pratiques">10.3 Recommandations Pratiques</h3>
<p>Pour une analyse optimale : 1. <strong>Prétraitement</strong> : Standardiser les variables, traiter les valeurs manquantes 2. <strong>Exploration</strong> : Tester plusieurs valeurs du seuil d’arrêt 3. <strong>Validation</strong> : Comparer avec une approche alternative (VAR-CAH, K-Means) 4. <strong>Interprétation</strong> : Analyser les valeurs propres à chaque division pour comprendre la qualité du partitionnement 5. <strong>Documentation</strong> : Tracer l’arbre de partition et justifier le choix du nombre final de clusters</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>