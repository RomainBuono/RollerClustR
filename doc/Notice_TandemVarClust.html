<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notice_tandemvarclust</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Notice_TandemVarClust_files/libs/clipboard/clipboard.min.js"></script>
<script src="Notice_TandemVarClust_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Notice_TandemVarClust_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Notice_TandemVarClust_files/libs/quarto-html/popper.min.js"></script>
<script src="Notice_TandemVarClust_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Notice_TandemVarClust_files/libs/quarto-html/anchor.min.js"></script>
<link href="Notice_TandemVarClust_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Notice_TandemVarClust_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Notice_TandemVarClust_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Notice_TandemVarClust_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Notice_TandemVarClust_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="implémentation-de-lalgorithme-tandemvarclust-dans-la-classe-tandemvarclust" class="level1">
<h1>Implémentation de l’Algorithme TandemVarClust dans la Classe TandemVarClust</h1>
<section id="fondements-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="fondements-théoriques">1. Fondements Théoriques</h2>
<section id="principe-général" class="level3">
<h3 class="anchored" data-anchor-id="principe-général">1.1 Principe Général</h3>
<p>L’implémentation proposée réalise un clustering hiérarchique de <strong>modalités</strong> (et non directement de variables) selon une approche Tandem combinant :</p>
<ol type="1">
<li><strong>AFDM</strong> (Analyse Factorielle de Données Mixtes) pour la réduction de dimensionnalité</li>
<li><strong>CAH</strong> (Classification Ascendante Hiérarchique) sur les coordonnées factorielles</li>
</ol>
<p>Cette méthode se distingue fondamentalement des approches classiques de clustering de variables (VAR_CAH, VARCLUS) car elle opère au niveau des <strong>modalités</strong> : chaque catégorie d’une variable qualitative ou chaque intervalle discrétisé d’une variable quantitative constitue une unité à classer. Ce changement d’échelle permet de capturer des structures plus fines et de traiter naturellement des données mixtes (quantitatives et qualitatives).</p>
</section>
<section id="architecture-logicielle" class="level3">
<h3 class="anchored" data-anchor-id="architecture-logicielle">1.2 Architecture Logicielle</h3>
<p>La classe <code>TandemVarClust</code> hérite de la classe abstraite <code>ClusterAnalysis</code> et implémente une architecture R6 garantissant l’encapsulation des données et la modularité des traitements. Les attributs privés assurent la persistance des résultats intermédiaires nécessaires aux analyses ultérieures et à l’assignation de variables illustratives.</p>
</section>
<section id="positionnement-méthodologique" class="level3">
<h3 class="anchored" data-anchor-id="positionnement-méthodologique">1.3 Positionnement Méthodologique</h3>
<p>Le clustering Tandem (aussi appelé “two-step clustering”) consiste en une approche séquentielle où l’analyse factorielle précède le clustering proprement dit. Bien que critiquée par certains auteurs (Arabie &amp; Hubert, 1994 ; De Soete &amp; Carroll, 1994) pour des raisons d’optimalité conjointe, cette approche présente l’avantage de la simplicité algorithmique et de l’interprétabilité : les axes factoriels retenus pour le clustering peuvent être examinés indépendamment.</p>
<p>L’utilisation de l’AFDM comme première étape permet de traiter des tableaux mixtes (variables quantitatives et qualitatives) dans un cadre unifié, ce qui constitue un avantage décisif dans les applications pratiques où la mixité des données est la règle plutôt que l’exception.</p>
</section>
</section>
<section id="traduction-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="traduction-algorithmique">2. Traduction Algorithmique</h2>
<section id="phase-de-prétraitement-préparation-des-données-mixtes" class="level3">
<h3 class="anchored" data-anchor-id="phase-de-prétraitement-préparation-des-données-mixtes">2.1 Phase de Prétraitement : Préparation des Données Mixtes</h3>
<section id="identification-des-types-de-variables" class="level4">
<h4 class="anchored" data-anchor-id="identification-des-types-de-variables">Identification des Types de Variables</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>prepare_mixed_data <span class="ot">=</span> <span class="cf">function</span>(X) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  var_types <span class="ot">&lt;-</span> <span class="fu">sapply</span>(X, <span class="cf">function</span>(col) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.factor</span>(col) <span class="sc">||</span> <span class="fu">is.character</span>(col)) <span class="st">"categorical"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">is.numeric</span>(col)) <span class="st">"numeric"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="st">"unknown"</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FCatVarNames <span class="ot">&lt;-</span> <span class="fu">names</span>(var_types)[var_types <span class="sc">==</span> <span class="st">"categorical"</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FNumVarNames <span class="ot">&lt;-</span> <span class="fu">names</span>(var_types)[var_types <span class="sc">==</span> <span class="st">"numeric"</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FHasCategoricalVars <span class="ot">&lt;-</span> <span class="fu">length</span>(private<span class="sc">$</span>FCatVarNames) <span class="sc">&gt;</span> <span class="dv">0</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FHasNumericVars <span class="ot">&lt;-</span> <span class="fu">length</span>(private<span class="sc">$</span>FNumVarNames) <span class="sc">&gt;</span> <span class="dv">0</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La méthode débute par une inspection du type de chaque variable. Cette distinction est cruciale car le traitement diffère radicalement selon la nature des variables :</p>
<ul>
<li><strong>Variables qualitatives</strong> : Codées par tableau disjonctif complet (indicatrices)</li>
<li><strong>Variables quantitatives</strong> : Discrétisées puis codées par indicatrices</li>
</ul>
</section>
<section id="construction-du-tableau-disjonctif-variables-qualitatives" class="level4">
<h4 class="anchored" data-anchor-id="construction-du-tableau-disjonctif-variables-qualitatives">Construction du Tableau Disjonctif : Variables Qualitatives</h4>
<p>Pour chaque variable qualitative <span class="math inline">\(V_j\)</span> possédant <span class="math inline">\(m_j\)</span> modalités, on crée <span class="math inline">\(m_j\)</span> colonnes indicatrices. Si la variable <span class="math inline">\(V\)</span> possède les modalités <span class="math inline">\(\{A, B, C\}\)</span>, on construit trois colonnes :</p>
<p><span class="math display">\[
\begin{pmatrix}
V.A \\
V.B \\
V.C
\end{pmatrix}
=
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0
\end{pmatrix}
\]</span></p>
<p>où l’élément <span class="math inline">\((i,k)\)</span> vaut 1 si l’observation <span class="math inline">\(i\)</span> possède la modalité <span class="math inline">\(k\)</span>, et 0 sinon.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (var_name <span class="cf">in</span> private<span class="sc">$</span>FCatVarNames) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  col <span class="ot">&lt;-</span> X[[var_name]]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.factor</span>(col)) col <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(col)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  levels_var <span class="ot">&lt;-</span> <span class="fu">levels</span>(col)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (level <span class="cf">in</span> levels_var) {</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    indicator <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(col <span class="sc">==</span> level)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    col_name <span class="ot">&lt;-</span> <span class="fu">paste0</span>(var_name, <span class="st">"."</span>, level)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    disjunctive_list[[col_name]] <span class="ot">&lt;-</span> indicator</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette transformation est au cœur de l’Analyse des Correspondances Multiples (ACM), composante de l’AFDM pour les variables qualitatives.</p>
</section>
<section id="discrétisation-et-codage-variables-quantitatives" class="level4">
<h4 class="anchored" data-anchor-id="discrétisation-et-codage-variables-quantitatives">Discrétisation et Codage : Variables Quantitatives</h4>
<p>Les variables quantitatives ne peuvent être directement intégrées dans un tableau disjonctif. L’approche adoptée consiste à :</p>
<ol type="1">
<li><strong>Discrétiser</strong> la variable en <span class="math inline">\(n_{\text{bins}}\)</span> intervalles (par défaut 5)</li>
<li><strong>Coder</strong> chaque intervalle par une indicatrice</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (var_name <span class="cf">in</span> private<span class="sc">$</span>FNumVarNames) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  col <span class="ot">&lt;-</span> X[[var_name]]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Standardisation optionnelle</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (private<span class="sc">$</span>FScale) {</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    col <span class="ot">&lt;-</span> <span class="fu">scale</span>(col)[, <span class="dv">1</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Discrétisation par quantiles</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  breaks <span class="ot">&lt;-</span> <span class="fu">quantile</span>(col, <span class="at">probs =</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out =</span> private<span class="sc">$</span>FNBins <span class="sc">+</span> <span class="dv">1</span>), </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                     <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  breaks <span class="ot">&lt;-</span> <span class="fu">unique</span>(breaks)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  discretized <span class="ot">&lt;-</span> <span class="fu">cut</span>(col, <span class="at">breaks =</span> breaks, <span class="at">include.lowest =</span> <span class="cn">TRUE</span>, <span class="at">labels =</span> <span class="cn">FALSE</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Création des indicatrices</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  n_bins_actual <span class="ot">&lt;-</span> <span class="fu">max</span>(discretized, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (bin <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_bins_actual) {</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    indicator <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(discretized <span class="sc">==</span> bin)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    col_name <span class="ot">&lt;-</span> <span class="fu">paste0</span>(var_name, <span class="st">".bin"</span>, bin)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    disjunctive_list[[col_name]] <span class="ot">&lt;-</span> indicator</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Justification de la discrétisation</strong> : Cette étape transforme une variable continue en variable ordinale, permettant son intégration dans le cadre de l’ACM. Les quantiles sont privilégiés pour garantir des effectifs équilibrés dans chaque intervalle, optimisant ainsi la qualité de l’analyse factorielle ultérieure.</p>
<p><strong>Nombre de bins</strong> : Le paramètre <code>n_bins</code> (par défaut 5) contrôle le niveau de granularité : - <strong>Peu de bins (3-5)</strong> : Perte d’information mais robustesse accrue - <strong>Beaucoup de bins (10-20)</strong> : Conservation de l’information mais risque de sur-ajustement</p>
</section>
<section id="structure-finale-du-tableau-disjonctif" class="level4">
<h4 class="anchored" data-anchor-id="structure-finale-du-tableau-disjonctif">Structure Finale du Tableau Disjonctif</h4>
<p>À l’issue de cette étape, on dispose d’une matrice <span class="math inline">\(\mathbf{Z}\)</span> de dimensions <span class="math inline">\(n \times p^*\)</span> où :</p>
<p><span class="math display">\[p^* = \sum_{j \in \text{qual}} m_j + \sum_{j \in \text{quant}} n_{\text{bins},j}\]</span></p>
<p>Cette matrice vérifie la propriété de <strong>partition</strong> : pour chaque variable d’origine, exactement une modalité est active par observation.</p>
</section>
</section>
<section id="phase-danalyse-factorielle-afdm" class="level3">
<h3 class="anchored" data-anchor-id="phase-danalyse-factorielle-afdm">2.2 Phase d’Analyse Factorielle : AFDM</h3>
<p>L’AFDM réalise une analyse factorielle sur le tableau disjonctif <span class="math inline">\(\mathbf{Z}\)</span>, combinant les principes de l’ACP (pour les variables quantitatives originelles) et de l’ACM (pour les variables qualitatives).</p>
<section id="pondération-et-centrage" class="level4">
<h4 class="anchored" data-anchor-id="pondération-et-centrage">Pondération et Centrage</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>perform_factorial_analysis <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  Z <span class="ot">&lt;-</span> private<span class="sc">$</span>FDisjunctiveTable</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Z)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Z)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pondération des colonnes (inverse des fréquences marginales)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  col_margins <span class="ot">&lt;-</span> <span class="fu">colSums</span>(Z) <span class="sc">/</span> n</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  col_weights <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">/</span> col_margins</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  col_weights[<span class="sc">!</span><span class="fu">is.finite</span>(col_weights)] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pondération des lignes (uniforme)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  row_weights <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span>n, n)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Centrage</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  Z_centered <span class="ot">&lt;-</span> <span class="fu">sweep</span>(Z, <span class="dv">2</span>, col_margins, <span class="st">"-"</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Pondération des modalités</strong> : L’utilisation de l’inverse des fréquences marginales <span class="math inline">\(f_k = \frac{n_k}{n}\)</span> où <span class="math inline">\(n_k\)</span> est l’effectif de la modalité <span class="math inline">\(k\)</span> garantit que :</p>
<p><span class="math display">\[w_k = \frac{1}{f_k}\]</span></p>
<p>Cette pondération compense le déséquilibre potentiel entre modalités fréquentes et rares. Une modalité rare (faible <span class="math inline">\(f_k\)</span>) reçoit un poids élevé (<span class="math inline">\(w_k\)</span> grand), augmentant son influence dans l’analyse factorielle.</p>
</section>
<section id="décomposition-en-valeurs-singulières" class="level4">
<h4 class="anchored" data-anchor-id="décomposition-en-valeurs-singulières">Décomposition en Valeurs Singulières</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Matrices de pondération</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>D_col_sqrt <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">sqrt</span>(col_weights))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>D_row_sqrt <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">sqrt</span>(row_weights))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Matrice pondérée</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>Z_weighted <span class="ot">&lt;-</span> D_row_sqrt <span class="sc">%*%</span> Z_centered <span class="sc">%*%</span> D_col_sqrt</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># SVD</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>svd_res <span class="ot">&lt;-</span> <span class="fu">svd</span>(Z_weighted)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La SVD de la matrice pondérée <span class="math inline">\(\mathbf{Z}_w = \mathbf{D}_r^{1/2} \mathbf{Z}_c \mathbf{D}_c^{1/2}\)</span> s’écrit :</p>
<p><span class="math display">\[\mathbf{Z}_w = \mathbf{U} \boldsymbol{\Lambda} \mathbf{V}^T\]</span></p>
<p>où : - <span class="math inline">\(\mathbf{U}\)</span> : Matrice des vecteurs propres gauches (axes factoriels pour les observations) - <span class="math inline">\(\boldsymbol{\Lambda}\)</span> : Matrice diagonale des valeurs singulières - <span class="math inline">\(\mathbf{V}\)</span> : Matrice des vecteurs propres droits (axes factoriels pour les modalités)</p>
</section>
<section id="coordonnées-factorielles-des-modalités" class="level4">
<h4 class="anchored" data-anchor-id="coordonnées-factorielles-des-modalités">Coordonnées Factorielles des Modalités</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Coordonnées factorielles des modalités</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FFactorialCoords <span class="ot">&lt;-</span> D_col_sqrt <span class="sc">%*%</span> svd_res<span class="sc">$</span>v</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(private<span class="sc">$</span>FFactorialCoords) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(Z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Les coordonnées factorielles <span class="math inline">\(\boldsymbol{\Phi}\)</span> des modalités sont données par :</p>
<p><span class="math display">\[\boldsymbol{\Phi} = \mathbf{D}_c^{1/2} \mathbf{V}\]</span></p>
<p>Chaque ligne de <span class="math inline">\(\boldsymbol{\Phi}\)</span> correspond à une modalité, chaque colonne à un axe factoriel. Ces coordonnées positionnent chaque modalité dans l’espace factoriel et serviront de base au clustering.</p>
</section>
<section id="valeurs-propres-et-inertie" class="level4">
<h4 class="anchored" data-anchor-id="valeurs-propres-et-inertie">Valeurs Propres et Inertie</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Valeurs propres et variance expliquée</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>eigenvalues <span class="ot">&lt;-</span> svd_res<span class="sc">$</span>d<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FACMVariance <span class="ot">&lt;-</span> <span class="dv">100</span> <span class="sc">*</span> eigenvalues <span class="sc">/</span> <span class="fu">sum</span>(eigenvalues)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FInertie <span class="ot">&lt;-</span> <span class="fu">sum</span>(eigenvalues)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Les valeurs propres <span class="math inline">\(\lambda_k = d_k^2\)</span> quantifient la variance expliquée par chaque axe factoriel. L’<strong>inertie totale</strong> est définie par :</p>
<p><span class="math display">\[I_{\text{tot}} = \sum_{k=1}^{p^*} \lambda_k\]</span></p>
<p>Le pourcentage de variance expliquée par l’axe <span class="math inline">\(k\)</span> est :</p>
<p><span class="math display">\[\text{Var\%}_k = \frac{\lambda_k}{I_{\text{tot}}} \times 100\]</span></p>
<p>Cette métrique permet de sélectionner le nombre d’axes factoriels à retenir pour le clustering.</p>
</section>
</section>
<section id="phase-de-classification-hiérarchique" class="level3">
<h3 class="anchored" data-anchor-id="phase-de-classification-hiérarchique">2.3 Phase de Classification Hiérarchique</h3>
<section id="sélection-des-axes-factoriels" class="level4">
<h4 class="anchored" data-anchor-id="sélection-des-axes-factoriels">Sélection des Axes Factoriels</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>perform_clustering <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  n_factors_to_use <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="fu">is.null</span>(private<span class="sc">$</span>FNFactors)) {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    private<span class="sc">$</span>FNFactorsTotal</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">min</span>(private<span class="sc">$</span>FNFactors, private<span class="sc">$</span>FNFactorsTotal)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  coords <span class="ot">&lt;-</span> private<span class="sc">$</span>FFactorialCoords[, <span class="dv">1</span><span class="sc">:</span>n_factors_to_use, drop <span class="ot">=</span> <span class="cn">FALSE</span>]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le paramètre <code>n_factors</code> permet de régulariser le clustering en limitant le nombre d’axes factoriels utilisés. Deux stratégies existent :</p>
<ul>
<li><strong><code>n_factors = NULL</code></strong> : Utilisation de tous les axes (approche exhaustive)</li>
<li><strong><code>n_factors = 2-5</code></strong> : Régularisation par restriction aux premiers axes principaux</li>
</ul>
<p><strong>Justification théorique</strong> : Les derniers axes factoriels capturent souvent du bruit plutôt que de la structure. Les restreindre améliore la robustesse du clustering au détriment d’une légère perte d’information.</p>
</section>
<section id="distance-euclidienne-et-arbre-hiérarchique" class="level4">
<h4 class="anchored" data-anchor-id="distance-euclidienne-et-arbre-hiérarchique">Distance Euclidienne et Arbre Hiérarchique</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Distance euclidienne dans l'espace factoriel</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>dist_matrix <span class="ot">&lt;-</span> <span class="fu">dist</span>(coords, <span class="at">method =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Classification Ascendante Hiérarchique</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FHclustTree <span class="ot">&lt;-</span> <span class="fu">hclust</span>(dist_matrix, <span class="at">method =</span> private<span class="sc">$</span>FMethodCAH)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La CAH construit un dendrogramme en agrégeant itérativement les modalités selon un critère de fusion. La distance entre deux modalités <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> dans l’espace factoriel à <span class="math inline">\(q\)</span> dimensions est :</p>
<p><span class="math display">\[d(i,j) = \sqrt{\sum_{k=1}^{q} (\phi_{ik} - \phi_{jk})^2}\]</span></p>
<p>où <span class="math inline">\(\phi_{ik}\)</span> désigne la coordonnée de la modalité <span class="math inline">\(i\)</span> sur l’axe <span class="math inline">\(k\)</span>.</p>
</section>
<section id="méthode-de-ward" class="level4">
<h4 class="anchored" data-anchor-id="méthode-de-ward">Méthode de Ward</h4>
<p>La méthode de Ward (par défaut <code>"ward.D2"</code>) minimise l’augmentation d’inertie intra-classe à chaque fusion. Pour deux clusters <span class="math inline">\(C_i\)</span> et <span class="math inline">\(C_j\)</span>, le critère de fusion est :</p>
<p><span class="math display">\[\Delta(C_i, C_j) = \frac{|C_i| \cdot |C_j|}{|C_i| + |C_j|} \|m_i - m_j\|^2\]</span></p>
<p>où <span class="math inline">\(m_i\)</span> et <span class="math inline">\(m_j\)</span> sont les centroïdes des clusters, et <span class="math inline">\(|\cdot|\)</span> dénote la cardinalité.</p>
<p>Cette méthode favorise la création de clusters compacts et équilibrés en effectif.</p>
</section>
<section id="coupe-de-larbre" class="level4">
<h4 class="anchored" data-anchor-id="coupe-de-larbre">Coupe de l’Arbre</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Partition en K clusters</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FGroupes <span class="ot">&lt;-</span> <span class="fu">cutree</span>(private<span class="sc">$</span>FHclustTree, <span class="at">k =</span> private<span class="sc">$</span>FNbGroupes)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(private<span class="sc">$</span>FGroupes) <span class="ot">&lt;-</span> <span class="fu">rownames</span>(coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La partition finale est obtenue en coupant le dendrogramme au niveau <span class="math inline">\(K\)</span> spécifié. On obtient un vecteur d’assignations :</p>
<p><span class="math display">\[\mathbf{c} = (c_1, \ldots, c_{p^*}) \quad \text{où} \quad c_i \in \{1, \ldots, K\}\]</span></p>
<p>Chaque modalité <span class="math inline">\(i\)</span> est assignée à un cluster <span class="math inline">\(c_i\)</span>.</p>
</section>
</section>
<section id="reconfiguration-dynamique-modification-de-k" class="level3">
<h3 class="anchored" data-anchor-id="reconfiguration-dynamique-modification-de-k">2.4 Reconfiguration Dynamique : Modification de K</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>refit_with_k <span class="ot">=</span> <span class="cf">function</span>(new_k) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(private<span class="sc">$</span>FHclustTree)) {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">stop</span>(<span class="st">"Le modèle n'est pas encore ajusté."</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FNbGroupes <span class="ot">&lt;-</span> new_k</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  private<span class="sc">$</span>FGroupes <span class="ot">&lt;-</span> <span class="fu">cutree</span>(private<span class="sc">$</span>FHclustTree, <span class="at">k =</span> new_k)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">message</span>(<span class="st">"Modèle réajusté avec K = "</span>, new_k)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>L’avantage de la CAH réside dans sa structure hiérarchique : le dendrogramme encode <strong>toutes les partitions possibles</strong>. Modifier <span class="math inline">\(K\)</span> ne nécessite donc qu’une nouvelle coupe de l’arbre, sans réexécuter les étapes d’AFDM et de calcul de distances.</p>
<p>Cette fonctionnalité permet une exploration rapide de différentes valeurs de <span class="math inline">\(K\)</span> pour identifier la partition optimale selon un critère externe (silhouette, gap statistic, expertise métier).</p>
</section>
</section>
<section id="prédiction-de-variables-illustratives" class="level2">
<h2 class="anchored" data-anchor-id="prédiction-de-variables-illustratives">3. Prédiction de Variables Illustratives</h2>
<section id="principe-du-clustering-de-modalités-au-clustering-dobservations" class="level3">
<h3 class="anchored" data-anchor-id="principe-du-clustering-de-modalités-au-clustering-dobservations">3.1 Principe : du Clustering de Modalités au Clustering d’Observations</h3>
<p><strong>Problématique fondamentale</strong> : Le modèle TandemVarClust produit des clusters de <strong>modalités</strong>, mais pour analyser une variable illustrative, il faut assigner chaque <strong>observation</strong> à un cluster.</p>
<p><strong>Solution adoptée</strong> : Assignation par indice de similarité de Dice.</p>
</section>
<section id="assignation-par-indice-de-dice" class="level3">
<h3 class="anchored" data-anchor-id="assignation-par-indice-de-dice">3.2 Assignation par Indice de Dice</h3>
<section id="fondement-théorique" class="level4">
<h4 class="anchored" data-anchor-id="fondement-théorique">Fondement Théorique</h4>
<p>L’assignation des observations aux clusters repose sur l’<strong>indice de Dice</strong> (Dice, 1945), coefficient de similarité établi pour mesurer la ressemblance entre deux ensembles.</p>
<p>Pour une observation <span class="math inline">\(i\)</span> possédant un ensemble de modalités actives <span class="math inline">\(M_i\)</span> et un cluster <span class="math inline">\(k\)</span> contenant un ensemble de modalités <span class="math inline">\(C_k\)</span>, l’indice de Dice est défini par :</p>
<p><span class="math display">\[\text{Dice}(M_i, C_k) = \frac{2|M_i \cap C_k|}{|M_i| + |C_k|}\]</span></p>
<p>où <span class="math inline">\(|M_i \cap C_k|\)</span> représente le nombre de modalités communes entre l’observation et le cluster.</p>
<p>L’observation est assignée au cluster maximisant cet indice :</p>
<p><span class="math display">\[\hat{c}_i = \arg\max_{k=1,\ldots,K} \text{Dice}(M_i, C_k)\]</span></p>
</section>
<section id="implémentation" class="level4">
<h4 class="anchored" data-anchor-id="implémentation">Implémentation</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>assign_observations_to_clusters <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  Z <span class="ot">&lt;-</span> private<span class="sc">$</span>FDisjunctiveTable</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Z)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  groupes <span class="ot">&lt;-</span> private<span class="sc">$</span>FGroupes</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  K <span class="ot">&lt;-</span> private<span class="sc">$</span>FNbGroupes</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  obs_clusters <span class="ot">&lt;-</span> <span class="fu">integer</span>(n)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  dice_scores <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> K)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Identifier les modalités de chaque cluster</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  cluster_modalities <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span>K, <span class="cf">function</span>(k) {</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">which</span>(groupes <span class="sc">==</span> k)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n) {</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Modalités actives de l'observation i</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    modalities_i <span class="ot">&lt;-</span> <span class="fu">which</span>(Z[i, ] <span class="sc">==</span> <span class="dv">1</span>)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    n_modalities_i <span class="ot">&lt;-</span> <span class="fu">length</span>(modalities_i)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (n_modalities_i <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>      obs_clusters[i] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>      dice_scores[i, ] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">next</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculer Dice avec chaque cluster</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K) {</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>      modalities_k <span class="ot">&lt;-</span> cluster_modalities[[k]]</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>      n_modalities_k <span class="ot">&lt;-</span> <span class="fu">length</span>(modalities_k)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Intersection</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>      intersection <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">intersect</span>(modalities_i, modalities_k))</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Indice de Dice</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (n_modalities_i <span class="sc">+</span> n_modalities_k <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        dice_scores[i, k] <span class="ot">&lt;-</span> (<span class="dv">2</span> <span class="sc">*</span> intersection) <span class="sc">/</span> (n_modalities_i <span class="sc">+</span> n_modalities_k)</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> {</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>        dice_scores[i, k] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assigner au cluster avec Dice maximum</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    obs_clusters[i] <span class="ot">&lt;-</span> <span class="fu">which.max</span>(dice_scores[i, ])</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>    <span class="at">clusters =</span> obs_clusters,</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>    <span class="at">scores =</span> dice_scores</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="justification-méthodologique" class="level4">
<h4 class="anchored" data-anchor-id="justification-méthodologique">Justification Méthodologique</h4>
<p>L’indice de Dice est particulièrement adapté au clustering de modalités car il :</p>
<ol type="1">
<li><strong>Respecte la nature discrète</strong> des ensembles de modalités (Kaufman &amp; Rousseeuw, 1990)</li>
<li><strong>Corrige le biais</strong> induit par les clusters de tailles différentes grâce à une normalisation symétrique</li>
<li><strong>Fournit une mesure de similarité normalisée</strong> entre 0 et 1, facilitant l’interprétation</li>
<li><strong>Gère les profils d’observations variables</strong> : Une observation avec peu de modalités actives n’est pas pénalisée par rapport à une observation avec beaucoup de modalités</li>
</ol>
<p><strong>Comparaison avec l’indice de Jaccard</strong> : L’indice de Dice est préféré à l’indice de Jaccard :</p>
<p><span class="math display">\[\text{Jaccard}(M_i, C_k) = \frac{|M_i \cap C_k|}{|M_i \cup C_k|}\]</span></p>
<p>L’indice de Dice (basé sur la moyenne harmonique) donne plus de poids à l’intersection que le Jaccard (basé sur la moyenne arithmétique), ce qui est plus approprié lorsque la présence de modalités est plus informative que l’absence.</p>
<p>Cette approche est cohérente avec les pratiques de caractérisation de classes en analyse de données catégorielles (Le Roux &amp; Rouanet, 2004).</p>
<p><strong>Sortie</strong> : Cette méthode retourne non seulement les assignations aux clusters mais également une matrice de scores de Dice pour chaque paire observation-cluster, permettant une analyse post-hoc de la confiance d’assignation.</p>
</section>
<section id="propriétés-de-lindice-de-dice" class="level4">
<h4 class="anchored" data-anchor-id="propriétés-de-lindice-de-dice">Propriétés de l’Indice de Dice</h4>
<p><strong>Propriétés mathématiques</strong> :</p>
<ol type="1">
<li><strong>Symétrie</strong> : <span class="math inline">\(\text{Dice}(A, B) = \text{Dice}(B, A)\)</span></li>
<li><strong>Bornes</strong> : <span class="math inline">\(0 \leq \text{Dice}(A, B) \leq 1\)</span></li>
<li><strong>Identité</strong> : <span class="math inline">\(\text{Dice}(A, A) = 1\)</span></li>
<li><strong>Similarité nulle</strong> : <span class="math inline">\(\text{Dice}(A, B) = 0 \Leftrightarrow A \cap B = \emptyset\)</span></li>
</ol>
<p><strong>Avantages par rapport au vote majoritaire simple</strong> :</p>
<ul>
<li><strong>Normalisation des tailles</strong> : Le dénominateur <span class="math inline">\(|M_i| + |C_k|\)</span> normalise à la fois pour les tailles d’observation et de cluster</li>
<li><strong>Évaluation quantitative</strong> : Fournit des scores continus (0 à 1) plutôt que des comptages discrets</li>
<li><strong>Fondement théorique</strong> : Bien établi en écologie et en recherche d’information</li>
<li><strong>Interprétabilité</strong> : Le score représente la proportion de chevauchement par rapport au total des modalités</li>
</ul>
<p><strong>Efficacité computationnelle</strong> : L’algorithme a une complexité <span class="math inline">\(O(n \times K \times p^*)\)</span> où : - <span class="math inline">\(n\)</span> : nombre d’observations - <span class="math inline">\(K\)</span> : nombre de clusters - <span class="math inline">\(p^*\)</span> : nombre de modalités</p>
<p>Ceci est efficace pour les tailles de jeux de données typiquement rencontrées en pratique.</p>
</section>
</section>
<section id="construction-du-tableau-de-contingence" class="level3">
<h3 class="anchored" data-anchor-id="construction-du-tableau-de-contingence">3.3 Construction du Tableau de Contingence</h3>
<p>Une fois les observations assignées aux clusters via l’indice de Dice, l’analyse des variables illustratives procède :</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>predict <span class="ot">=</span> <span class="cf">function</span>(newdata) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Assigner les observations aux clusters via l'indice de Dice</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> private<span class="sc">$</span><span class="fu">assign_observations_to_clusters</span>()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  obs_clusters <span class="ot">&lt;-</span> result<span class="sc">$</span>clusters</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  dice_scores <span class="ot">&lt;-</span> result<span class="sc">$</span>scores</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (var_name <span class="cf">in</span> <span class="fu">names</span>(newdata)) {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    var_col <span class="ot">&lt;-</span> newdata[[var_name]]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.factor</span>(var_col)) var_col <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(var_col)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Tableau de contingence</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    contingency <span class="ot">&lt;-</span> <span class="fu">table</span>(var_col, obs_clusters)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">colnames</span>(contingency) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"Cluster_"</span>, <span class="fu">colnames</span>(contingency))</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le tableau de contingence croise les modalités de la variable illustrative avec les clusters d’observations :</p>
<p><span class="math display">\[
\begin{array}{c|ccc|c}
&amp; \text{Cluster 1} &amp; \text{Cluster 2} &amp; \text{Cluster 3} &amp; \text{Total} \\
\hline
\text{Modalité A} &amp; n_{A1} &amp; n_{A2} &amp; n_{A3} &amp; n_{A\cdot} \\
\text{Modalité B} &amp; n_{B1} &amp; n_{B2} &amp; n_{B3} &amp; n_{B\cdot} \\
\text{Modalité C} &amp; n_{C1} &amp; n_{C2} &amp; n_{C3} &amp; n_{C\cdot} \\
\hline
\text{Total} &amp; n_{\cdot 1} &amp; n_{\cdot 2} &amp; n_{\cdot 3} &amp; n
\end{array}
\]</span></p>
</section>
<section id="tests-statistiques-chi-deux-et-v-de-cramer" class="level3">
<h3 class="anchored" data-anchor-id="tests-statistiques-chi-deux-et-v-de-cramer">3.4 Tests Statistiques : Chi-Deux et V de Cramer</h3>
<section id="test-du-chi-deux" class="level4">
<h4 class="anchored" data-anchor-id="test-du-chi-deux">Test du Chi-Deux</h4>
<p>Le test du <span class="math inline">\(\chi^2\)</span> évalue l’indépendance entre la variable illustrative et les clusters :</p>
<p><span class="math display">\[\chi^2 = \sum_{i=1}^{r} \sum_{j=1}^{c} \frac{(n_{ij} - e_{ij})^2}{e_{ij}}\]</span></p>
<p>où <span class="math inline">\(e_{ij} = \frac{n_{i\cdot} n_{\cdot j}}{n}\)</span> est l’effectif théorique sous l’hypothèse d’indépendance.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>chi2_test <span class="ot">&lt;-</span> <span class="fu">chisq.test</span>(contingency)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Interprétation</strong> : - <strong>p-valeur &lt; 0.05</strong> : Rejet de l’indépendance → La variable illustrative est significativement liée aux clusters - <strong>p-valeur ≥ 0.05</strong> : Non-rejet → Pas de liaison significative détectée</p>
</section>
<section id="coefficient-v-de-cramer" class="level4">
<h4 class="anchored" data-anchor-id="coefficient-v-de-cramer">Coefficient V de Cramer</h4>
<p>Le V de Cramer mesure l’<strong>intensité</strong> de la liaison entre deux variables qualitatives :</p>
<p><span class="math display">\[V = \sqrt{\frac{\chi^2}{n \times \min(r-1, c-1)}}\]</span></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>compute_cramers_v <span class="ot">=</span> <span class="cf">function</span>(contingency) {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  chi2 <span class="ot">&lt;-</span> <span class="fu">suppressWarnings</span>(<span class="fu">chisq.test</span>(contingency)<span class="sc">$</span>statistic)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">sum</span>(contingency)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  min_dim <span class="ot">&lt;-</span> <span class="fu">min</span>(<span class="fu">nrow</span>(contingency) <span class="sc">-</span> <span class="dv">1</span>, <span class="fu">ncol</span>(contingency) <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (min_dim <span class="sc">==</span> <span class="dv">0</span>) <span class="fu">return</span>(<span class="cn">NA</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  v <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(chi2 <span class="sc">/</span> (n <span class="sc">*</span> min_dim))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">as.numeric</span>(v))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Échelle d’interprétation</strong> :</p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 30%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>V de Cramer</th>
<th>Interprétation</th>
<th>Signification pratique</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.00 - 0.10</td>
<td>Liaison négligeable</td>
<td>Clusters et variable indépendants</td>
</tr>
<tr class="even">
<td>0.10 - 0.30</td>
<td>Liaison faible</td>
<td>Association détectable mais limitée</td>
</tr>
<tr class="odd">
<td>0.30 - 0.50</td>
<td>Liaison modérée</td>
<td>Structure partiellement expliquée</td>
</tr>
<tr class="even">
<td>0.50 - 0.70</td>
<td>Liaison forte</td>
<td>Bonne correspondance</td>
</tr>
<tr class="odd">
<td>&gt; 0.70</td>
<td>Liaison très forte</td>
<td>Clusters largement déterminés par la variable</td>
</tr>
</tbody>
</table>
<p><strong>Avantage du V de Cramer</strong> : Contrairement au <span class="math inline">\(\chi^2\)</span>, le V de Cramer est normalisé dans <span class="math inline">\([0, 1]\)</span> et indépendant de la taille d’échantillon, permettant des comparaisons entre études.</p>
</section>
</section>
<section id="structure-des-résultats" class="level3">
<h3 class="anchored" data-anchor-id="structure-des-résultats">3.5 Structure des Résultats</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>results[[var_name]] <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">contingency =</span> contingency,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">percentages_by_modality =</span> pct_row,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">percentages_by_cluster =</span> pct_col,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">chi2_test =</span> chi2_test,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">cramers_v =</span> private<span class="sc">$</span><span class="fu">compute_cramers_v</span>(contingency),</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">significant =</span> chi2_test<span class="sc">$</span>p.value <span class="sc">&lt;</span> <span class="fl">0.05</span>,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">dice_scores =</span> dice_scores</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La méthode <code>predict()</code> retourne une liste structurée pour chaque variable illustrative :</p>
<ol type="1">
<li><strong><code>contingency</code></strong> : Tableau de contingence brut (effectifs)</li>
<li><strong><code>percentages_by_modality</code></strong> : Profils lignes (somme = 100% par modalité)</li>
<li><strong><code>percentages_by_cluster</code></strong> : Profils colonnes (somme = 100% par cluster)</li>
<li><strong><code>chi2_test</code></strong> : Objet de classe <code>htest</code> contenant le <span class="math inline">\(\chi^2\)</span>, ddl et p-valeur</li>
<li><strong><code>cramers_v</code></strong> : Coefficient V de Cramer</li>
<li><strong><code>significant</code></strong> : Booléen indiquant la significativité au seuil de 5%</li>
<li><strong><code>dice_scores</code></strong> : Matrice des scores de Dice pour chaque paire observation-cluster</li>
</ol>
<p>L’inclusion de <code>dice_scores</code> permet aux utilisateurs de : - Évaluer la confiance d’assignation pour chaque observation - Identifier les observations avec des assignations ambiguës (scores similaires sur plusieurs clusters) - Réaliser des analyses de sensibilité sur les assignations aux clusters</p>
</section>
<section id="interprétation-des-profils" class="level3">
<h3 class="anchored" data-anchor-id="interprétation-des-profils">3.6 Interprétation des Profils</h3>
<section id="profils-lignes-percentages-by-modality" class="level4">
<h4 class="anchored" data-anchor-id="profils-lignes-percentages-by-modality">Profils Lignes (Percentages by Modality)</h4>
<p>Les profils lignes indiquent <strong>où se répartissent</strong> les observations d’une modalité donnée :</p>
<p>Exemple :</p>
<pre><code>            Cluster_1  Cluster_2  Cluster_3
Modalité_A     25%        60%        15%</code></pre>
<p><strong>Lecture</strong> : Parmi les observations ayant la modalité A, 25% appartiennent au cluster 1, 60% au cluster 2, 15% au cluster 3.</p>
</section>
<section id="profils-colonnes-percentages-by-cluster" class="level4">
<h4 class="anchored" data-anchor-id="profils-colonnes-percentages-by-cluster">Profils Colonnes (Percentages by Cluster)</h4>
<p>Les profils colonnes indiquent <strong>la composition</strong> de chaque cluster :</p>
<p>Exemple :</p>
<pre><code>            Cluster_1  Cluster_2  Cluster_3
Modalité_A     40%        20%        10%
Modalité_B     30%        50%        30%
Modalité_C     30%        30%        60%</code></pre>
<p><strong>Lecture</strong> : Dans le cluster 1, 40% des observations ont la modalité A, 30% la modalité B, 30% la modalité C.</p>
</section>
</section>
<section id="cas-dusage-pratique" class="level3">
<h3 class="anchored" data-anchor-id="cas-dusage-pratique">3.7 Cas d’Usage Pratique</h3>
<p><strong>Scénario</strong> : Clustering de modalités de données socio-démographiques (Sexe, Âge discrétisé, CSP, Région). Variable illustrative : <code>Comportement d'achat</code> (3 modalités : Économe, Équilibré, Dépensier).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clustering principal</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> TandemVarClust<span class="sc">$</span><span class="fu">new</span>(<span class="at">K =</span> <span class="dv">3</span>, <span class="at">n_factors =</span> <span class="dv">3</span>, <span class="at">n_bins =</span> <span class="dv">5</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">fit</span>(data_socio_demo)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyse de la variable illustrative</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> model<span class="sc">$</span><span class="fu">predict</span>(<span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">Comportement =</span> comportement_achat))</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Examen des résultats</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"V de Cramer:"</span>, results<span class="sc">$</span>Comportement<span class="sc">$</span>cramers_v, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co"># V de Cramer: 0.52</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Test du Chi-deux:</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(results<span class="sc">$</span>Comportement<span class="sc">$</span>chi2_test)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># p-value &lt; 0.001</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Profils par modalité:</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(results<span class="sc">$</span>Comportement<span class="sc">$</span>percentages_by_modality)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co">#              Cluster_1  Cluster_2  Cluster_3</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Économe          12%        78%        10%</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Équilibré        45%        40%        15%</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Dépensier        68%        20%        12%</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Examen de la confiance d'assignation</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Scores Dice moyens par cluster:</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">colMeans</span>(results<span class="sc">$</span>Comportement<span class="sc">$</span>dice_scores, <span class="at">na.rm =</span> <span class="cn">TRUE</span>))</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Cluster_1: 0.67  Cluster_2: 0.71  Cluster_3: 0.58</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Interprétation</strong> :</p>
<ol type="1">
<li><strong>V = 0.52</strong> : Liaison forte entre comportement d’achat et clusters de modalités socio-démographiques</li>
<li><strong>p &lt; 0.001</strong> : Liaison statistiquement très significative</li>
<li><strong>Profils</strong> :
<ul>
<li>Cluster 2 : Majoritairement “Économes” (78%) avec une confiance d’assignation élevée (0.71)</li>
<li>Cluster 1 : Plutôt “Dépensiers” (68%) avec une bonne confiance (0.67)</li>
<li>Cluster 3 : Distribution plus homogène avec une confiance plus faible (0.58)</li>
</ul></li>
<li><strong>Scores Dice</strong> : Les scores Dice moyens indiquent que les assignations du Cluster 3 sont moins confiantes, suggérant que ces observations ont des profils plus hétérogènes</li>
</ol>
<p><strong>Conclusion</strong> : Les clusters capturent des profils socio-démographiques fortement liés au comportement d’achat. Une analyse détaillée des modalités de chaque cluster révélera les caractéristiques démographiques typiques de chaque segment comportemental.</p>
</section>
</section>
<section id="méthodes-utilitaires" class="level2">
<h2 class="anchored" data-anchor-id="méthodes-utilitaires">4. Méthodes Utilitaires</h2>
<section id="synthèse-par-variable-get_variable_summary" class="level3">
<h3 class="anchored" data-anchor-id="synthèse-par-variable-get_variable_summary">4.1 Synthèse par Variable : <code>get_variable_summary()</code></h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>get_variable_summary <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  groupes_modalites <span class="ot">&lt;-</span> self<span class="sc">$</span>Groupes</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  noms_modalites <span class="ot">&lt;-</span> <span class="fu">names</span>(groupes_modalites)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  noms_variables <span class="ot">&lt;-</span> <span class="fu">sub</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">..*"</span>, <span class="st">""</span>, noms_modalites)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Pour chaque variable, identifier le cluster principal et la pureté</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind, <span class="fu">lapply</span>(<span class="fu">unique</span>(noms_variables), <span class="cf">function</span>(v) {</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    subset_v <span class="ot">&lt;-</span> df[df<span class="sc">$</span>variable <span class="sc">==</span> v, ]</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    tbl <span class="ot">&lt;-</span> <span class="fu">table</span>(subset_v<span class="sc">$</span>cluster)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    cluster_principal <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(<span class="fu">names</span>(tbl)[<span class="fu">which.max</span>(tbl)])</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    purity <span class="ot">&lt;-</span> <span class="fu">max</span>(tbl) <span class="sc">/</span> <span class="fu">sum</span>(tbl)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">data.frame</span>(</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>      <span class="at">variable =</span> v,</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">n_modalites =</span> <span class="fu">nrow</span>(subset_v),</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>      <span class="at">cluster_principal =</span> cluster_principal,</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>      <span class="at">purity =</span> purity</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  }))</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette méthode agrège les résultats au niveau des variables d’origine, malgré le clustering des modalités. Deux indicateurs sont calculés :</p>
<ol type="1">
<li><strong>Cluster principal</strong> : Cluster contenant la majorité des modalités de la variable</li>
<li><strong>Pureté</strong> : Proportion de modalités dans le cluster principal</li>
</ol>
<p><span class="math display">\[\text{Pureté}(V_j) = \frac{\max_k \left|\{m \in V_j : c_m = k\}\right|}{|V_j|}\]</span></p>
<p><strong>Interprétation de la pureté</strong> :</p>
<ul>
<li><strong>Pureté = 1.0</strong> : Toutes les modalités de la variable dans un seul cluster → Variable homogène</li>
<li><strong>Pureté = 0.5</strong> : Modalités dispersées → Variable hétérogène</li>
<li><strong>Pureté &lt; 0.6</strong> : Signal d’alerte pour variables à examiner</li>
</ul>
<p><strong>Exemple</strong> :</p>
<pre><code>variable       n_modalites  cluster_principal  purity
Sexe                   2              1         1.00
Age_discretise         5              2         0.80
Region                10              3         0.40</code></pre>
<p><strong>Lecture</strong> : - <code>Sexe</code> : Pureté parfaite → Les 2 modalités (Homme, Femme) sont dans le même cluster - <code>Age_discretise</code> : 80% des 5 bins d’âge dans le cluster 2 → Structure d’âge assez homogène - <code>Region</code> : 40% des 10 régions dans le cluster 3 → Forte dispersion géographique</p>
</section>
<section id="modalités-dune-variable-get_modalities_of_variable" class="level3">
<h3 class="anchored" data-anchor-id="modalités-dune-variable-get_modalities_of_variable">4.2 Modalités d’une Variable : <code>get_modalities_of_variable()</code></h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>get_modalities_of_variable <span class="ot">=</span> <span class="cf">function</span>(variable_name) {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  groupes <span class="ot">&lt;-</span> self<span class="sc">$</span>Groupes</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  noms <span class="ot">&lt;-</span> <span class="fu">names</span>(groupes)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  pattern <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"^"</span>, variable_name, <span class="st">"</span><span class="sc">\\</span><span class="st">."</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  indices <span class="ot">&lt;-</span> <span class="fu">grep</span>(pattern, noms)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(indices) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">stop</span>(<span class="st">"Variable '"</span>, variable_name, <span class="st">"' non trouvée"</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">modalite =</span> <span class="fu">sub</span>(<span class="st">"^[^</span><span class="sc">\\</span><span class="st">.]+</span><span class="sc">\\</span><span class="st">."</span>, <span class="st">""</span>, noms[indices]),</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">cluster =</span> groupes[indices]</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette méthode détaille l’assignation de chaque modalité d’une variable spécifique, permettant une analyse fine de la structure capturée.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">get_modalities_of_variable</span>(<span class="st">"Region"</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   modalite  cluster</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">#   Nord          1</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">#   Sud           2</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">#   Est           2</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">#   Ouest         1</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">#   Centre        3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Interprétation</strong> : Les régions Nord et Ouest partagent le cluster 1, Sud et Est le cluster 2, tandis que Centre est isolé dans le cluster 3. Cela suggère une structure géographique sous-jacente capturée par le clustering.</p>
</section>
<section id="modalités-dun-cluster-get_modalities_of_cluster" class="level3">
<h3 class="anchored" data-anchor-id="modalités-dun-cluster-get_modalities_of_cluster">4.3 Modalités d’un Cluster : <code>get_modalities_of_cluster()</code></h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>get_modalities_of_cluster <span class="ot">=</span> <span class="cf">function</span>(k) {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  groupes <span class="ot">&lt;-</span> self<span class="sc">$</span>Groupes</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  noms <span class="ot">&lt;-</span> <span class="fu">names</span>(groupes)[groupes <span class="sc">==</span> k]</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">variable =</span> <span class="fu">sub</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">..*"</span>, <span class="st">""</span>, noms),</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">modalite =</span> <span class="fu">sub</span>(<span class="st">"^[^</span><span class="sc">\\</span><span class="st">.]+</span><span class="sc">\\</span><span class="st">."</span>, <span class="st">""</span>, noms)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette méthode inverse permet d’examiner la <strong>composition</strong> d’un cluster en termes de modalités et de variables d’origine.</p>
<p><strong>Exemple</strong> :</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">get_modalities_of_cluster</span>(<span class="dv">1</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   variable       modalite</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">#   Sexe           Homme</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">#   Age            bin1</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">#   Age            bin2</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co">#   CSP            Cadre</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co">#   Region         Nord</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Interprétation</strong> : Le cluster 1 regroupe des hommes, jeunes (bins 1-2), cadres, du Nord. Profil socio-démographique cohérent suggérant un segment de “jeunes cadres urbains du Nord”.</p>
</section>
<section id="vérification-dintégrité-check_results_integrity" class="level3">
<h3 class="anchored" data-anchor-id="vérification-dintégrité-check_results_integrity">4.4 Vérification d’Intégrité : <code>check_results_integrity()</code></h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>check_results_integrity <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  groupes <span class="ot">&lt;-</span> self<span class="sc">$</span>Groupes</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  issues <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Vérification 1 : Tous les clusters ont des modalités</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  cluster_counts <span class="ot">&lt;-</span> <span class="fu">table</span>(groupes)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  empty_clusters <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">:</span>self<span class="sc">$</span>K)[<span class="sc">!</span><span class="dv">1</span><span class="sc">:</span>self<span class="sc">$</span>K <span class="sc">%in%</span> <span class="fu">as.integer</span>(<span class="fu">names</span>(cluster_counts))]</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(empty_clusters) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    issues<span class="sc">$</span>empty_clusters <span class="ot">&lt;-</span> empty_clusters</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Vérification 2 : Format des noms</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">all</span>(<span class="fu">grepl</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">."</span>, <span class="fu">names</span>(groupes)))) {</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    issues<span class="sc">$</span>invalid_names <span class="ot">&lt;-</span> <span class="fu">names</span>(groupes)[<span class="sc">!</span><span class="fu">grepl</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">."</span>, <span class="fu">names</span>(groupes))]</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(issues)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette méthode diagnostique assure la cohérence des résultats :</p>
<ol type="1">
<li><strong>Clusters vides</strong> : Vérifie qu’aucun cluster n’est vide (peut arriver avec certaines valeurs de K)</li>
<li><strong>Format des noms</strong> : Vérifie que chaque modalité suit le format <code>variable.modalite</code></li>
</ol>
</section>
</section>
<section id="fondements-mathématiques-et-validations" class="level2">
<h2 class="anchored" data-anchor-id="fondements-mathématiques-et-validations">5. Fondements Mathématiques et Validations</h2>
<section id="décomposition-en-valeurs-singulières-pondérée" class="level3">
<h3 class="anchored" data-anchor-id="décomposition-en-valeurs-singulières-pondérée">5.1 Décomposition en Valeurs Singulières Pondérée</h3>
<p>La SVD pondérée utilisée dans l’AFDM repose sur la décomposition :</p>
<p><span class="math display">\[\mathbf{D}_r^{1/2} (\mathbf{Z} - \mathbf{1} \mathbf{f}^T) \mathbf{D}_c^{1/2} = \mathbf{U} \boldsymbol{\Lambda} \mathbf{V}^T\]</span></p>
<p>où : - <span class="math inline">\(\mathbf{D}_r\)</span> : Matrice diagonale des poids des observations (lignes) - <span class="math inline">\(\mathbf{D}_c\)</span> : Matrice diagonale des poids des modalités (colonnes) - <span class="math inline">\(\mathbf{f}\)</span> : Vecteur des fréquences marginales des modalités</p>
<p>Cette décomposition généralise simultanément l’ACP (pour les variables quantitatives) et l’ACM (pour les variables qualitatives).</p>
</section>
<section id="relation-entre-inertie-et-valeurs-propres" class="level3">
<h3 class="anchored" data-anchor-id="relation-entre-inertie-et-valeurs-propres">5.2 Relation entre Inertie et Valeurs Propres</h3>
<p>L’inertie totale du nuage de points (modalités) dans l’espace factoriel est :</p>
<p><span class="math display">\[I_{\text{tot}} = \sum_{i=1}^{p^*} \sum_{k=1}^{q} w_i (\phi_{ik} - \bar{\phi}_k)^2 = \sum_{k=1}^{q} \lambda_k\]</span></p>
<p>où <span class="math inline">\(q\)</span> est le rang de <span class="math inline">\(\mathbf{Z}_c\)</span> (nombre d’axes factoriels non triviaux).</p>
<p>La variance expliquée par les <span class="math inline">\(q'\)</span> premiers axes est :</p>
<p><span class="math display">\[\text{Var\%}_{1:q'} = \frac{\sum_{k=1}^{q'} \lambda_k}{I_{\text{tot}}} \times 100\]</span></p>
<p>Cette métrique guide le choix de <code>n_factors</code> : on retient typiquement les axes expliquant cumulativement 70-80% de l’inertie.</p>
</section>
<section id="propriétés-du-v-de-cramer" class="level3">
<h3 class="anchored" data-anchor-id="propriétés-du-v-de-cramer">5.3 Propriétés du V de Cramer</h3>
<p>Le V de Cramer vérifie les propriétés suivantes :</p>
<ol type="1">
<li><strong>Domaine</strong> : <span class="math inline">\(V \in [0, 1]\)</span></li>
<li><strong>Indépendance</strong> : <span class="math inline">\(V = 0 \Leftrightarrow\)</span> indépendance stricte</li>
<li><strong>Liaison parfaite</strong> : <span class="math inline">\(V = 1\)</span> si et seulement si une liaison déterministe existe</li>
<li><strong>Invariance d’échelle</strong> : Insensible à la taille d’échantillon (à distribution fixée)</li>
</ol>
<p>La relation entre V et <span class="math inline">\(\chi^2\)</span> est :</p>
<p><span class="math display">\[V^2 = \frac{\chi^2}{n \times \min(r-1, c-1)}\]</span></p>
<p>Cette normalisation par <span class="math inline">\(\min(r-1, c-1)\)</span> compense l’effet du nombre de degrés de liberté, rendant V comparable entre tableaux de dimensions différentes.</p>
</section>
<section id="optimalité-de-la-cah-avec-ward" class="level3">
<h3 class="anchored" data-anchor-id="optimalité-de-la-cah-avec-ward">5.4 Optimalité de la CAH avec Ward</h3>
<p>Le critère de Ward minimise la <strong>perte d’inertie intra-classe</strong> à chaque fusion. Formellement, pour une partition <span class="math inline">\(\mathcal{P} = \{C_1, \ldots, C_K\}\)</span>, l’inertie intra-classe est :</p>
<p><span class="math display">\[I_{\text{intra}}(\mathcal{P}) = \sum_{k=1}^{K} \sum_{i \in C_k} w_i \|\boldsymbol{\phi}_i - \mathbf{m}_k\|^2\]</span></p>
<p>où <span class="math inline">\(\mathbf{m}_k = \frac{\sum_{i \in C_k} w_i \boldsymbol{\phi}_i}{\sum_{i \in C_k} w_i}\)</span> est le centroïde pondéré du cluster <span class="math inline">\(C_k\)</span>.</p>
<p>À chaque étape, Ward fusionne les clusters <span class="math inline">\(C_i\)</span> et <span class="math inline">\(C_j\)</span> minimisant :</p>
<p><span class="math display">\[\Delta I_{\text{intra}}(C_i, C_j) = I_{\text{intra}}(C_i \cup C_j) - [I_{\text{intra}}(C_i) + I_{\text{intra}}(C_j)]\]</span></p>
<p>Ce critère garantit la construction de clusters compacts dans l’espace factoriel.</p>
</section>
<section id="indice-de-dice-fondement-mathématique" class="level3">
<h3 class="anchored" data-anchor-id="indice-de-dice-fondement-mathématique">5.5 Indice de Dice : Fondement Mathématique</h3>
<p>Le coefficient de Dice peut s’exprimer en termes de cardinalités d’ensembles :</p>
<p><span class="math display">\[\text{Dice}(A, B) = \frac{2|A \cap B|}{|A| + |B|}\]</span></p>
<p>Cette formule peut être réécrite en termes de précision et de rappel :</p>
<p><span class="math display">\[\text{Dice}(A, B) = \frac{2 \cdot \text{Précision} \cdot \text{Rappel}}{\text{Précision} + \text{Rappel}}\]</span></p>
<p>où : - <span class="math inline">\(\text{Précision} = \frac{|A \cap B|}{|B|}\)</span> - <span class="math inline">\(\text{Rappel} = \frac{|A \cap B|}{|A|}\)</span></p>
<p>Cela montre que Dice est la moyenne harmonique de la précision et du rappel, lui conférant des propriétés favorables pour les comparaisons d’ensembles asymétriques.</p>
<p><strong>Relation avec le F1-score</strong> : En recherche d’information, le coefficient de Dice est équivalent au F1-score, une métrique largement utilisée pour la qualité de classification.</p>
</section>
</section>
<section id="complexité-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="complexité-algorithmique">6. Complexité Algorithmique</h2>
<section id="phase-dapprentissage" class="level3">
<h3 class="anchored" data-anchor-id="phase-dapprentissage">6.1 Phase d’Apprentissage</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Étape</th>
<th>Complexité</th>
<th>Dominante pour</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tableau disjonctif</td>
<td><span class="math inline">\(O(np)\)</span></td>
<td><span class="math inline">\(n\)</span> grand</td>
</tr>
<tr class="even">
<td>AFDM (SVD)</td>
<td><span class="math inline">\(O(\min(n^2 p^*, np^{*2}))\)</span></td>
<td><span class="math inline">\(p^* &gt; n\)</span></td>
</tr>
<tr class="odd">
<td>Distances</td>
<td><span class="math inline">\(O(p^{*2} q)\)</span></td>
<td><span class="math inline">\(p^*\)</span> grand</td>
</tr>
<tr class="even">
<td>CAH</td>
<td><span class="math inline">\(O(p^{*2} \log p^*)\)</span></td>
<td><span class="math inline">\(p^*\)</span> modéré</td>
</tr>
</tbody>
</table>
<p>où : - <span class="math inline">\(n\)</span> : Nombre d’observations - <span class="math inline">\(p\)</span> : Nombre de variables d’origine - <span class="math inline">\(p^*\)</span> : Nombre de modalités (typiquement <span class="math inline">\(p^* = 2-10 \times p\)</span>) - <span class="math inline">\(q\)</span> : Nombre d’axes factoriels retenus</p>
<p><strong>Complexité globale</strong> : Dominée par la SVD, soit <span class="math inline">\(O(\min(n^2 p^*, np^{*2}))\)</span>.</p>
</section>
<section id="phase-de-prédiction" class="level3">
<h3 class="anchored" data-anchor-id="phase-de-prédiction">6.2 Phase de Prédiction</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Étape</th>
<th>Complexité</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Assignation Dice</td>
<td><span class="math inline">\(O(n \times K \times p^*)\)</span></td>
</tr>
<tr class="even">
<td>Tableau de contingence</td>
<td><span class="math inline">\(O(n \times m_{\text{illus}})\)</span></td>
</tr>
<tr class="odd">
<td>Test du Chi-deux</td>
<td><span class="math inline">\(O(r \times c)\)</span></td>
</tr>
</tbody>
</table>
<p>où : - <span class="math inline">\(m_{\text{illus}}\)</span> : Nombre de modalités de la variable illustrative - <span class="math inline">\(r\)</span> : Nombre de lignes du tableau de contingence - <span class="math inline">\(c = K\)</span> : Nombre de clusters</p>
<p><strong>Complexité globale</strong> : <span class="math inline">\(O(n \times K \times p^*)\)</span> pour l’assignation Dice, qui est linéaire en <span class="math inline">\(n\)</span> et typiquement efficace pour les applications pratiques.</p>
</section>
</section>
<section id="limitations-et-extensions-possibles" class="level2">
<h2 class="anchored" data-anchor-id="limitations-et-extensions-possibles">7. Limitations et Extensions Possibles</h2>
<section id="limitations-actuelles" class="level3">
<h3 class="anchored" data-anchor-id="limitations-actuelles">7.1 Limitations Actuelles</h3>
<ol type="1">
<li><p><strong>Sensibilité à la discrétisation</strong> : Le choix de <code>n_bins</code> influence fortement les résultats pour les variables quantitatives. Une discrétisation trop grossière perd de l’information, une trop fine augmente la dimensionnalité et le bruit.</p></li>
<li><p><strong>Perte d’information ordinale</strong> : La discrétisation transforme des variables continues en variables nominales, perdant la structure d’ordre. Des extensions (ACM ordinale) pourraient préserver cette information.</p></li>
<li><p><strong>Difficulté d’interprétation au niveau des variables</strong> : Le clustering opérant sur les modalités, l’agrégation au niveau des variables (via <code>get_variable_summary()</code>) peut masquer des structures fines.</p></li>
<li><p><strong>Hypothèse d’indépendance conditionnelle</strong> : L’AFDM suppose implicitement une forme d’indépendance locale entre modalités d’une même variable, ce qui peut être violé dans certains contextes.</p></li>
<li><p><strong>Méthode d’assignation unique</strong> : Bien que l’indice de Dice soit bien adapté à la plupart des applications, certains contextes spécifiques pourraient bénéficier d’approches alternatives.</p></li>
</ol>
</section>
<section id="perspectives-dextension" class="level3">
<h3 class="anchored" data-anchor-id="perspectives-dextension">7.2 Perspectives d’Extension</h3>
<section id="extension-1-afdm-ordinale" class="level4">
<h4 class="anchored" data-anchor-id="extension-1-afdm-ordinale">Extension 1 : AFDM Ordinale</h4>
<p>Intégrer des contraintes d’ordre pour les variables quantitatives discrétisées, en utilisant des codages ordinaux plutôt que nominaux. Cela préserverait la structure de rang des bins.</p>
</section>
<section id="extension-2-sélection-automatique-de-k" class="level4">
<h4 class="anchored" data-anchor-id="extension-2-sélection-automatique-de-k">Extension 2 : Sélection Automatique de K</h4>
<p>Implémenter des critères d’optimalité pour déterminer automatiquement le nombre de clusters :</p>
<ul>
<li><strong>Indice de Davies-Bouldin</strong> : Minimise le ratio compacité/séparation</li>
<li><strong>Silhouette</strong> : Maximise la cohésion intra-cluster et séparation inter-clusters</li>
<li><strong>Gap Statistic</strong> : Compare l’inertie intra-classe observée à celle sous hypothèse nulle</li>
</ul>
</section>
<section id="extension-3-approche-simultanée-factorial-k-means" class="level4">
<h4 class="anchored" data-anchor-id="extension-3-approche-simultanée-factorial-k-means">Extension 3 : Approche Simultanée (Factorial K-Means)</h4>
<p>Plutôt qu’une approche séquentielle (AFDM puis CAH), développer une approche simultanée optimisant conjointement la réduction de dimensionnalité et le clustering, à la manière du Factorial K-Means de Vichi &amp; Kiers (2001).</p>
</section>
<section id="extension-4-robustification-par-bootstrap" class="level4">
<h4 class="anchored" data-anchor-id="extension-4-robustification-par-bootstrap">Extension 4 : Robustification par Bootstrap</h4>
<p>Pour chaque cluster, estimer des intervalles de confiance sur : - La composition en modalités - Les coordonnées du centroïde dans l’espace factoriel - Le V de Cramer pour les variables illustratives - Les distributions de scores Dice</p>
<p>Cela fournirait des mesures de stabilité des clusters et des intervalles de confiance pour les assignations.</p>
</section>
<section id="extension-5-variables-illustratives-quantitatives" class="level4">
<h4 class="anchored" data-anchor-id="extension-5-variables-illustratives-quantitatives">Extension 5 : Variables Illustratives Quantitatives</h4>
<p>Étendre <code>predict()</code> aux variables illustratives quantitatives, en calculant : - Moyennes et écarts-types par cluster - Tests ANOVA - Coefficients de corrélation point-bisériale - Tailles d’effet (d de Cohen, eta-carré)</p>
</section>
<section id="extension-6-visualisation-interactive" class="level4">
<h4 class="anchored" data-anchor-id="extension-6-visualisation-interactive">Extension 6 : Visualisation Interactive</h4>
<p>Développer des graphiques interactifs permettant de : - Explorer le dendrogramme et visualiser l’effet de différentes coupes - Projeter les clusters dans le premier plan factoriel avec étiquettes de modalités - Afficher dynamiquement les modalités d’un cluster sélectionné - Montrer les distributions de scores Dice pour l’évaluation de la confiance d’assignation</p>
</section>
<section id="extension-7-assignation-douce" class="level4">
<h4 class="anchored" data-anchor-id="extension-7-assignation-douce">Extension 7 : Assignation Douce</h4>
<p>Étendre l’assignation basée sur Dice pour fournir des appartenances probabilistes (soft) aux clusters plutôt que des assignations strictes (hard), en utilisant les scores Dice normalisés comme probabilités d’appartenance aux clusters.</p>
</section>
</section>
</section>
<section id="cas-dusage-et-applications" class="level2">
<h2 class="anchored" data-anchor-id="cas-dusage-et-applications">8. Cas d’Usage et Applications</h2>
<section id="segmentation-marketing" class="level3">
<h3 class="anchored" data-anchor-id="segmentation-marketing">8.1 Segmentation Marketing</h3>
<p><strong>Contexte</strong> : Segmentation de clients sur la base de données socio-démographiques mixtes (âge, revenu, catégorie socio-professionnelle, région, situation familiale).</p>
<p><strong>Avantages de TandemVarClust</strong> : - Traitement naturel des types de données mixtes - Clustering au niveau des modalités capturant des profils fins (ex : “Célibataires urbains 25-34 ans cadres” vs “Familles rurales 45-54 ans employés”) - Assignation basée sur Dice fournissant des scores de confiance pour l’appartenance de chaque client au segment - Variables illustratives (comportement d’achat, satisfaction) pour valider la pertinence des segments</p>
<p><strong>Valeur de l’indice de Dice</strong> : Les scores de confiance d’assignation permettent aux équipes marketing de : - Identifier les clients avec une appartenance ambiguë au segment - Prioriser les stratégies de ciblage en fonction de la confiance d’assignation - Détecter les cas limites nécessitant une révision manuelle</p>
</section>
<section id="analyse-de-questionnaires" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-questionnaires">8.2 Analyse de Questionnaires</h3>
<p><strong>Contexte</strong> : Enquête de satisfaction avec questions Likert (ordinales), questions ouvertes recodées (nominales), et quelques métriques quantitatives (âge, ancienneté).</p>
<p><strong>Avantages de TandemVarClust</strong> : - Identification de patterns de réponses cohérents au niveau des modalités - Clustering des modalités révélant des profils de répondants - Analyse des libres commentaires (variables illustratives) pour enrichir l’interprétation - Confiance d’assignation aidant à identifier les répondants avec des patterns de réponse incohérents ou atypiques</p>
</section>
<section id="épidémiologie-et-santé-publique" class="level3">
<h3 class="anchored" data-anchor-id="épidémiologie-et-santé-publique">8.3 Épidémiologie et Santé Publique</h3>
<p><strong>Contexte</strong> : Étude des déterminants de la santé à partir de données individuelles hétérogènes (antécédents médicaux, habitudes de vie, facteurs socio-économiques).</p>
<p><strong>Avantages de TandemVarClust</strong> : - Intégration de variables binaires (présence/absence de pathologies), ordinales (fréquence de consommation), et continues (IMC, âge) - Identification de syndromes de facteurs de risque (combinaisons de modalités à risque) - Variables illustratives (survenue d’événements de santé) pour valider les facteurs de risque - Scores Dice permettant l’identification de patients avec des profils de risque peu clairs nécessitant un suivi plus étroit</p>
</section>
<section id="analyse-de-données-textuelles-codées" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-données-textuelles-codées">8.4 Analyse de Données Textuelles Codées</h3>
<p><strong>Contexte</strong> : Analyse de contenu d’entretiens ou de documents, avec variables décrivant la présence de thèmes (binaire), intensité de tonalité (ordinale), et métadonnées (nominale et continue).</p>
<p><strong>Avantages de TandemVarClust</strong> : - Typologie de documents basée sur leurs caractéristiques sémantiques et contextuelles - Clustering fin au niveau des modalités révélant des co-occurrences thématiques - Variables illustratives (auteur, date, source) pour contextualiser les clusters - Confiance d’assignation aidant à identifier les documents avec des thèmes mixtes ou ambigus</p>
</section>
</section>
<section id="références-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="références-théoriques">9. Références Théoriques</h2>
<section id="analyse-factorielle-de-données-mixtes-afdm" class="level3">
<h3 class="anchored" data-anchor-id="analyse-factorielle-de-données-mixtes-afdm">9.1 Analyse Factorielle de Données Mixtes (AFDM)</h3>
<ul>
<li><p><strong>Escofier, B.</strong> (1979). <em>Traitement simultané de variables quantitatives et qualitatives</em>. Les Cahiers de l’Analyse des Données, IV(2), 137-146. &gt; Article fondateur introduisant le principe de l’analyse simultanée de variables mixtes dans le cadre de l’ACM.</p></li>
<li><p><strong>Pagès, J.</strong> (2004). <em>Analyse factorielle de données mixtes</em>. Revue de Statistique Appliquée, 52(4), 93-111. &gt; Article de référence consolidant les travaux antérieurs et démontrant l’équivalence entre les approches.</p></li>
<li><p><strong>Husson, F., Lê, S., &amp; Pagès, J.</strong> (2017). <em>Exploratory Multivariate Analysis by Example Using R</em> (2e éd.). CRC Press. &gt; Guide pratique des méthodes d’analyse multivariée avec R et FactoMineR, incluant l’AFDM.</p></li>
</ul>
</section>
<section id="clustering-tandem-et-approches-séquentielles" class="level3">
<h3 class="anchored" data-anchor-id="clustering-tandem-et-approches-séquentielles">9.2 Clustering Tandem et Approches Séquentielles</h3>
<ul>
<li><p><strong>Arabie, P., &amp; Hubert, L. J.</strong> (1994). <em>Cluster analysis in marketing research</em>. In: <em>Advanced Methods of Marketing Research</em> (R. P. Bagozzi, Ed.), Blackwell, 160-189. &gt; Critique de l’approche tandem séquentielle et introduction du terme “tandem analysis”.</p></li>
<li><p><strong>Vichi, M., &amp; Kiers, H. A. L.</strong> (2001). <em>Factorial k-means analysis for two-way data</em>. Computational Statistics &amp; Data Analysis, 37(1), 49-64. &gt; Proposition du Factorial K-means (FKM), généralisant RKM. Comparaison théorique et empirique avec l’approche tandem.</p></li>
</ul>
</section>
<section id="indices-de-similarité" class="level3">
<h3 class="anchored" data-anchor-id="indices-de-similarité">9.3 Indices de Similarité</h3>
<ul>
<li><p><strong>Dice, L. R.</strong> (1945). <em>Measures of the amount of ecologic association between species</em>. Ecology, 26(3), 297-302. &gt; Article original introduisant le coefficient de Dice pour mesurer la similarité entre ensembles.</p></li>
<li><p><strong>Kaufman, L., &amp; Rousseeuw, P. J.</strong> (1990). <em>Finding Groups in Data: An Introduction to Cluster Analysis</em>. Wiley. &gt; Ouvrage de référence sur le clustering, incluant la discussion des indices de similarité pour données catégorielles.</p></li>
<li><p><strong>Tan, P. N., Steinbach, M., &amp; Kumar, V.</strong> (2005). <em>Introduction to Data Mining</em>. Pearson. &gt; Traitement complet des mesures de similarité incluant Dice, Jaccard, et leurs applications.</p></li>
</ul>
</section>
<section id="classification-ascendante-hiérarchique" class="level3">
<h3 class="anchored" data-anchor-id="classification-ascendante-hiérarchique">9.4 Classification Ascendante Hiérarchique</h3>
<ul>
<li><p><strong>Ward, J. H., Jr.</strong> (1963). <em>Hierarchical grouping to optimize an objective function</em>. Journal of the American Statistical Association, 58(301), 236-244. &gt; Article original proposant le critère de Ward pour la CAH.</p></li>
<li><p><strong>Murtagh, F., &amp; Contreras, P.</strong> (2012). <em>Algorithms for hierarchical clustering: An overview</em>. Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery, 2(1), 86-97. &gt; Revue des méthodes de CAH avec analyse de complexité.</p></li>
</ul>
</section>
<section id="tests-dassociation-pour-variables-qualitatives" class="level3">
<h3 class="anchored" data-anchor-id="tests-dassociation-pour-variables-qualitatives">9.5 Tests d’Association pour Variables Qualitatives</h3>
<ul>
<li><p><strong>Cramér, H.</strong> (1946). <em>Mathematical Methods of Statistics</em>. Princeton University Press. &gt; Ouvrage classique introduisant le coefficient V de Cramér.</p></li>
<li><p><strong>Agresti, A.</strong> (2013). <em>Categorical Data Analysis</em> (3e éd.). Wiley. &gt; Référence moderne sur l’analyse de données catégorielles, incluant les tests du Chi² et les mesures d’association.</p></li>
</ul>
</section>
<section id="éléments-supplémentaires-en-analyse-factorielle" class="level3">
<h3 class="anchored" data-anchor-id="éléments-supplémentaires-en-analyse-factorielle">9.6 Éléments Supplémentaires en Analyse Factorielle</h3>
<ul>
<li><p><strong>Greenacre, M.</strong> (2007). <em>Correspondence Analysis in Practice</em> (2e éd.). Chapman &amp; Hall/CRC. &gt; Traitement complet de l’analyse des correspondances incluant les éléments supplémentaires.</p></li>
<li><p><strong>Le Roux, B., &amp; Rouanet, H.</strong> (2004). <em>Geometric Data Analysis: From Correspondence Analysis to Structured Data Analysis</em>. Kluwer Academic Publishers. &gt; Approche géométrique de l’analyse de données, incluant le traitement des individus supplémentaires et la caractérisation de classes.</p></li>
</ul>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">10. Conclusion</h2>
<p>L’implémentation de <code>TandemVarClust</code> offre une approche focalisée et théoriquement solide pour le clustering de modalités dans le contexte de données mixtes. En combinant l’AFDM pour la réduction de dimensionnalité, la CAH pour le clustering, et l’indice de Dice pour l’assignation des observations, cette méthode fournit :</p>
<ol type="1">
<li><strong>Traitement naturel des données hétérogènes</strong> : Variables quantitatives et qualitatives dans un même cadre</li>
<li><strong>Capture de structures fines</strong> : Clustering au niveau des modalités révélant des patterns que le clustering de variables masquerait</li>
<li><strong>Interprétabilité riche</strong> : Via les méthodes utilitaires d’agrégation par variable et d’analyse de variables illustratives</li>
<li><strong>Rigueur méthodologique</strong> : L’indice de Dice fournit une méthode d’assignation mathématiquement solide et bien établie</li>
<li><strong>Flexibilité</strong> : Paramètres de régularisation (<code>n_factors</code>, <code>n_bins</code>) permettant d’adapter la méthode au contexte</li>
<li><strong>Confiance d’assignation</strong> : Les scores Dice permettant l’évaluation de la qualité des assignations aux clusters</li>
</ol>
<p>Le choix de l’indice de similarité de Dice comme unique méthode d’assignation est justifié par : - Son fondement théorique solide dans la mesure de similarité d’ensembles - Son traitement équilibré des tailles d’observation et de cluster - Son interprétabilité naturelle comme proportion de chevauchement - Son historique éprouvé en écologie, recherche d’information, et analyse de données catégorielles - Sa fourniture de scores de confiance continus pour les assignations</p>
<p>La méthode s’inscrit dans la tradition de l’école française d’analyse des données, privilégiant l’exploration et l’interprétation sur la modélisation paramétrique. Elle constitue un outil précieux pour les praticiens confrontés à des données réelles complexes et hétérogènes, notamment dans les domaines du marketing, des sciences sociales, de la santé publique et de l’analyse textuelle.</p>
<p>La focalisation de l’implémentation sur une méthode d’assignation unique et bien justifiée améliore : - La maintenabilité et la clarté du code - L’expérience utilisateur (pas de choix de méthode requis) - La reproductibilité des analyses - La cohérence théorique de l’approche globale</p>
<hr>
<p><strong>Document rédigé dans le cadre du développement du package R <code>RollerClustR</code></strong><br>
<strong>Auteur</strong> : Romain Buono <strong>Date</strong> : Novembre 2025<br>
<strong>Licence</strong> : MIT</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>