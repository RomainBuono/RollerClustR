<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notice_var_kmeans</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Notice_VAR_Kmeans_files/libs/clipboard/clipboard.min.js"></script>
<script src="Notice_VAR_Kmeans_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Notice_VAR_Kmeans_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Notice_VAR_Kmeans_files/libs/quarto-html/popper.min.js"></script>
<script src="Notice_VAR_Kmeans_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Notice_VAR_Kmeans_files/libs/quarto-html/anchor.min.js"></script>
<link href="Notice_VAR_Kmeans_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Notice_VAR_Kmeans_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Notice_VAR_Kmeans_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Notice_VAR_Kmeans_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Notice_VAR_Kmeans_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="implémentation-de-lalgorithme-var-kmeans-dans-la-classe-var_kmeans" class="level1">
<h1>Implémentation de l’Algorithme VAR-KMEANS dans la Classe VAR_KMEANS</h1>
<section id="fondements-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="fondements-théoriques">1. Fondements Théoriques</h2>
<section id="principe-général" class="level3">
<h3 class="anchored" data-anchor-id="principe-général">1.1 Principe Général</h3>
<p>L’implémentation proposée réalise un clustering de variables selon une approche de partitionnement itératif (K-Means), basée sur les travaux de <strong>Vigneau &amp; Qannari</strong>. L’objectif est de partitionner un ensemble de <span class="math inline">\(p\)</span> variables en <span class="math inline">\(K\)</span> groupes disjoints, de telle sorte que les variables d’un même groupe soient fortement corrélées à une variable synthétique latente représentant ce groupe.</p>
<p>Cette méthode se distingue du K-Means classique par deux aspects fondamentaux :</p>
<ol type="1">
<li><strong>L’objet classé</strong> : On classe des variables (colonnes) basées sur leurs profils d’observations.</li>
<li><strong>La représentation du centre</strong> : Le centre d’un cluster n’est pas la moyenne arithmétique des variables, mais la <strong>première composante principale</strong> du groupe.</li>
</ol>
</section>
<section id="architecture-logicielle" class="level3">
<h3 class="anchored" data-anchor-id="architecture-logicielle">1.2 Architecture Logicielle</h3>
<p>La classe <code>VAR_KMEANS</code> hérite de la classe abstraite <code>ClusterAnalysis</code> et implémente une architecture R6. Contrairement à l’approche hiérarchique (VAR_CAH) qui nécessite le calcul coûteux d’une matrice de dissimilarité <span class="math inline">\(p \times p\)</span>, cette implémentation est optimisée pour traiter des jeux de données de haute dimension grâce à une complexité linéaire en nombre de variables.</p>
<p>Les attributs privés assurent la persistance des centres des clusters (les composantes principales), permettant l’utilisation du modèle pour la projection de nouvelles variables (mode prédictif).</p>
</section>
</section>
<section id="traduction-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="traduction-algorithmique">2. Traduction Algorithmique</h2>
<section id="phase-de-prétraitement-et-initialisation" class="level3">
<h3 class="anchored" data-anchor-id="phase-de-prétraitement-et-initialisation">2.1 Phase de Prétraitement et Initialisation</h3>
<section id="standardisation-et-structure-des-données" class="level4">
<h4 class="anchored" data-anchor-id="standardisation-et-structure-des-données">Standardisation et Structure des Données</h4>
<p>L’algorithme opère sur des variables centrées et réduites pour garantir l’équivalence entre covariance et corrélation.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (private<span class="sc">$</span>FScale) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  X_scaled <span class="ot">&lt;-</span> <span class="fu">scale</span>(X, <span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Transposition : les lignes deviennent les variables pour le traitement interne</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>private<span class="sc">$</span>FX_scaled <span class="ot">&lt;-</span> <span class="fu">t</span>(X_scaled)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La transposition interne (<code>private$FX_scaled</code>) est cruciale : les opérations vectorielles s’effectuent sur les lignes de cette matrice (qui sont les variables d’origine).</p>
</section>
<section id="stratégie-dinitialisation-multiple" class="level4">
<h4 class="anchored" data-anchor-id="stratégie-dinitialisation-multiple">Stratégie d’Initialisation Multiple</h4>
<p>Le K-Means étant sensible aux optimums locaux, l’algorithme implémente une stratégie de redémarrage multiple (<code>n_init</code>) pour assurer la robustesse de la solution. En effet, un des défauts de l’algorithme K-Means dans cette implémentation concerne le problème de l’optimum local. À chaque étape d’itération, l’algorithme cherche la meilleure amélioration possible à partir de l’état actuel.Cependant, il n’explore pas toutes les configurations possibles. Si l’initialisation des centres est mauvaise, l’algorithme peut rapidement converger vers une solution qui est localement optimale (la meilleure possible dans un voisinage immédiat) mais qui est loin de l’optimum global (la meilleure solution possible sur l’ensemble du domaine). Le critère d’optimisation est l’inertie définie par la somme des corrélations au carré (<span class="math inline">\(r^2\)</span>) :<span class="math display">\[\max T = \sum_{k=1}^K \sum_{j \in C_k} r^2(x_j, u_k)\]</span>Une mauvaise initialisation peut conduire à une partition qui donne une valeur <span class="math inline">\(T\)</span> faible, même si l’algorithme a “convergé” (c’est-à-dire que l’affectation des variables n’évolue plus).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>kmeans_multiple_runs <span class="ot">=</span> <span class="cf">function</span>() {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  best_criterion <span class="ot">&lt;-</span> <span class="sc">-</span><span class="cn">Inf</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>private<span class="sc">$</span>Fn_init) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... exécution d'un run ...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (result<span class="sc">$</span>inertia <span class="sc">&gt;</span> best_criterion) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      best_result <span class="ot">&lt;-</span> result</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>L’initialisation des centres est protégée pour garantir qu’aucun cluster ne soit vide au démarrage, combinant assignation aléatoire et vérification de contraintes.</p>
</section>
</section>
<section id="algorithme-itératif-allocation-représentation" class="level3">
<h3 class="anchored" data-anchor-id="algorithme-itératif-allocation-représentation">2.2 Algorithme Itératif (Allocation-Représentation)</h3>
<p>L’algorithme alterne entre deux étapes jusqu’à convergence ou atteinte du nombre maximal d’itérations (<code>max_iter</code>).</p>
<section id="étape-1-allocation-assignment-step" class="level4">
<h4 class="anchored" data-anchor-id="étape-1-allocation-assignment-step">Étape 1 : Allocation (Assignment Step)</h4>
<p>Chaque variable est affectée au cluster dont le centre (variable latente) est le plus proche. La mesure de proximité est le <strong>coefficient de corrélation au carré</strong> (<span class="math inline">\(r^2\)</span>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>assign_to_clusters <span class="ot">=</span> <span class="cf">function</span>(centers) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_vars) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    var_j <span class="ot">&lt;-</span> private<span class="sc">$</span>FX_scaled[j, ]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des corrélations carrées avec chaque centre k</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    scores <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>K, <span class="cf">function</span>(k) <span class="fu">cor</span>(var_j, centers[k, ])<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    clusters[j] <span class="ot">&lt;-</span> <span class="fu">which.max</span>(scores)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On assigne la variable <span class="math inline">\(x_j\)</span> au cluster <span class="math inline">\(k\)</span> maximisant <span class="math inline">\(r^2(x_j, u_k)\)</span>, où <span class="math inline">\(u_k\)</span> est le centre du cluster <span class="math inline">\(k\)</span>. Cela permet de regrouper des variables corrélées positivement ou négativement (colinéarité).</p>
</section>
<section id="étape-2-représentation-update-step" class="level4">
<h4 class="anchored" data-anchor-id="étape-2-représentation-update-step">Étape 2 : Représentation (Update Step)</h4>
<p>Les centres des clusters sont mis à jour. Pour un cluster <span class="math inline">\(C_k\)</span> contenant un sous-ensemble de variables, le nouveau centre <span class="math inline">\(u_k\)</span> est la première composante principale de ces variables.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>compute_cluster_center <span class="ot">=</span> <span class="cf">function</span>(var_indices) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ... extraction des données du cluster ...</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  cluster_centered <span class="ot">&lt;-</span> ...</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Décomposition spectrale de la matrice de corrélation</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  R <span class="ot">&lt;-</span> <span class="fu">cor</span>(<span class="fu">t</span>(cluster_centered))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  eigen_result <span class="ot">&lt;-</span> <span class="fu">eigen</span>(R, <span class="at">symmetric =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calcul du score factoriel (Composante Principale)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  v1 <span class="ot">&lt;-</span> eigen_result<span class="sc">$</span>vectors[, <span class="dv">1</span>]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  pc1 <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(<span class="fu">t</span>(cluster_centered) <span class="sc">%*%</span> v1)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Normalisation</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(pc1 <span class="sc">/</span> <span class="fu">sd</span>(pc1))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette étape garantit que le centre <span class="math inline">\(u_k\)</span> résume au mieux la variance structurelle du groupe.</p>
</section>
</section>
<section id="critère-de-convergence" class="level3">
<h3 class="anchored" data-anchor-id="critère-de-convergence">2.3 Critère de Convergence</h3>
<p>La boucle s’arrête lorsque l’affectation des variables aux clusters ne change plus entre deux itérations consécutives (<code>all(clusters == old_clusters)</code>).</p>
<p>L’algorithme maximise le critère d’inertie intra-classe défini par : <span class="math display">\[T = \sum_{k=1}^K \sum_{j \in C_k} r^2(x_j, u_k)\]</span></p>
</section>
</section>
<section id="prédiction-de-nouvelles-variables" class="level2">
<h2 class="anchored" data-anchor-id="prédiction-de-nouvelles-variables">3. Prédiction de Nouvelles Variables</h2>
<section id="principe-projection-sur-espace-fixe" class="level3">
<h3 class="anchored" data-anchor-id="principe-projection-sur-espace-fixe">3.1 Principe : Projection sur Espace Fixe</h3>
<p>La méthode <code>do_predict</code> permet d’associer de <strong>nouvelles variables</strong> aux clusters existants. Une particularité importante de cette méthode est qu’elle requiert que les nouvelles variables soient mesurées sur les <strong>mêmes observations</strong> (mêmes individus) que celles ayant servi à l’apprentissage.</p>
</section>
<section id="vérification-dintégrité-dimensionnelle" class="level3">
<h3 class="anchored" data-anchor-id="vérification-dintégrité-dimensionnelle">3.2 Vérification d’Intégrité Dimensionnelle</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">nrow</span>(newdata) <span class="sc">!=</span> <span class="fu">ncol</span>(private<span class="sc">$</span>FX_scaled)) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stop</span>(<span class="st">"newdata must have "</span>, <span class="fu">ncol</span>(private<span class="sc">$</span>FX_scaled), <span class="st">" observations"</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Cette contrainte est mathématique : pour calculer la corrélation entre une nouvelle variable <span class="math inline">\(v_{new}\)</span> et un centre de cluster <span class="math inline">\(u_k\)</span>, les deux vecteurs doivent avoir la même longueur <span class="math inline">\(n\)</span> (nombre d’observations). Le “centre” est ici un vecteur de scores factoriels défini sur les individus de référence.</p>
</section>
<section id="algorithme-de-prédiction" class="level3">
<h3 class="anchored" data-anchor-id="algorithme-de-prédiction">3.3 Algorithme de Prédiction</h3>
<p>Pour chaque nouvelle variable fournie :</p>
<ol type="1">
<li>Calcul de sa corrélation avec chacun des <span class="math inline">\(K\)</span> centres mémorisés (<code>private$FClusterCenters</code>).</li>
<li>Identification du cluster maximisant le <span class="math inline">\(r^2\)</span>.</li>
<li>Restitution du cluster d’appartenance et du score de proximité.</li>
</ol>
</section>
</section>
<section id="méthodes-utilitaires" class="level2">
<h2 class="anchored" data-anchor-id="méthodes-utilitaires">4. Méthodes Utilitaires</h2>
<section id="get_cluster_centers" class="level3">
<h3 class="anchored" data-anchor-id="get_cluster_centers">4.1 <code>get_cluster_centers()</code></h3>
<p>Retourne la matrice des composantes principales (variables latentes) de chaque cluster.</p>
<ul>
<li><strong>Dimensions</strong> : <span class="math inline">\(n\)</span> observations <span class="math inline">\(\times K\)</span> clusters.</li>
<li><strong>Usage</strong> : Ces centres peuvent servir de “super-variables” pour réduire la dimensionnalité dans des modèles ultérieurs (régression sur composantes latentes).</li>
</ul>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">4.2 <code>summary()</code></h3>
<p>Affiche les métriques de qualité du clustering :</p>
<ul>
<li><strong>Sum of r² (criterion)</strong> : La valeur de la fonction objectif maximisée.</li>
<li><strong>Homogénéité</strong> : Moyenne pondérée des <span class="math inline">\(r^2\)</span>, indiquant la part de variance des variables expliquée par la partition.</li>
<li><strong>Détails par cluster</strong> : Liste des variables et homogénéité interne de chaque groupe.</li>
</ul>
</section>
</section>
<section id="fondements-mathématiques" class="level2">
<h2 class="anchored" data-anchor-id="fondements-mathématiques">5. Fondements Mathématiques</h2>
<section id="décomposition-en-valeurs-propres" class="level3">
<h3 class="anchored" data-anchor-id="décomposition-en-valeurs-propres">5.1 Décomposition en Valeurs Propres</h3>
<p>L’algorithme repose sur le résultat théorique suivant : pour un ensemble de variables centrées-réduites <span class="math inline">\(X_k\)</span>, le vecteur <span class="math inline">\(u\)</span> de norme 1 qui maximise la somme des corrélations au carré <span class="math inline">\(\sum r^2(x_j, u)\)</span> est le premier vecteur propre de la matrice <span class="math inline">\(X_k'X_k\)</span> (ou de la matrice de corrélation).</p>
<p>L’algorithme est donc une alternance entre :</p>
<ul>
<li>Partitionnement conditionnel aux centres.</li>
<li>Analyse en Composantes Principales (ACP) locale conditionnelle à la partition.</li>
</ul>
</section>
<section id="relation-avec-linertie" class="level3">
<h3 class="anchored" data-anchor-id="relation-avec-linertie">5.2 Relation avec l’Inertie</h3>
<p>Dans l’espace des variables (sphère unité), maximiser la corrélation au carré <span class="math inline">\(r^2(x, u)\)</span> revient à minimiser la distance sinusoïdale ou la distance euclidienne carrée entre la variable <span class="math inline">\(x\)</span> et l’axe porté par <span class="math inline">\(u\)</span>.</p>
</section>
</section>
<section id="complexité-algorithmique" class="level2">
<h2 class="anchored" data-anchor-id="complexité-algorithmique">6. Complexité Algorithmique</h2>
<section id="phase-dapprentissage" class="level3">
<h3 class="anchored" data-anchor-id="phase-dapprentissage">6.1 Phase d’Apprentissage</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Étape</th>
<th style="text-align: left;">Complexité</th>
<th style="text-align: left;">Comparaison avec VAR_CAH</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialisation</td>
<td style="text-align: left;"><span class="math inline">\(O(n_{\text{init}} \cdot K)\)</span></td>
<td style="text-align: left;">Négligeable</td>
</tr>
<tr class="even">
<td style="text-align: left;">Itération (Allocation)</td>
<td style="text-align: left;"><span class="math inline">\(O(n \cdot p \cdot K)\)</span></td>
<td style="text-align: left;">Très rapide</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Itération (Update)</td>
<td style="text-align: left;"><span class="math inline">\(O(n \cdot p)\)</span> (dominé par SVD locale)</td>
<td style="text-align: left;">Rapide si <span class="math inline">\(p\)</span> est bien réparti</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Total</strong></td>
<td style="text-align: left;"><strong><span class="math inline">\(O(I \cdot n \cdot p \cdot K)\)</span></strong></td>
<td style="text-align: left;"><strong>Linéaire en <span class="math inline">\(p\)</span></strong></td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline">\(n\)</span> : nombre d’observations</li>
<li><span class="math inline">\(p\)</span> : nombre de variables</li>
<li><span class="math inline">\(K\)</span> : nombre de clusters</li>
<li><span class="math inline">\(I\)</span> : nombre d’itérations</li>
</ul>
<p>L’algorithme est particulièrement adapté aux cas où <span class="math inline">\(p\)</span> (nombre de variables) est très grand, là où une CAH en <span class="math inline">\(O(p^2)\)</span> deviendrait prohibitive.</p>
</section>
</section>
<section id="limitations-et-extensions" class="level2">
<h2 class="anchored" data-anchor-id="limitations-et-extensions">7. Limitations et Extensions</h2>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">7.1 Limitations</h3>
<ol type="1">
<li><strong>Choix de K</strong> : Le nombre de clusters doit être fixé a priori. Il n’y a pas de structure hiérarchique permettant de couper l’arbre a posteriori.</li>
<li><strong>Sensibilité à l’initialisation</strong> : Bien que compensée par <code>n_init</code>, la convergence vers un optimum global n’est pas garantie.</li>
<li><strong>Contrainte de prédiction</strong> : Impossible de projeter le modèle sur de <em>nouveaux individus</em> directement (les centres sont liés aux individus d’entraînement).</li>
</ol>
</section>
<section id="extensions-possibles" class="level3">
<h3 class="anchored" data-anchor-id="extensions-possibles">7.2 Extensions Possibles</h3>
<ul>
<li><strong>Algorithme Hybride</strong> : Utiliser VAR_KMEANS pour réduire un très grand nombre de variables (ex: 10 000) à un nombre modéré de groupes (ex: 100), puis appliquer une CAH sur les centres de ces groupes (approche “Two-step clustering of variables”).</li>
<li><strong>Sélection de variables</strong> : Introduire un seuil de <span class="math inline">\(r^2\)</span> minimal pour exclure les variables “bruit” qui ne s’alignent avec aucun centre (cluster “poubelle”).</li>
</ul>
</section>
</section>
<section id="cas-dusage-et-applications" class="level2">
<h2 class="anchored" data-anchor-id="cas-dusage-et-applications">8. Cas d’Usage et Applications</h2>
<section id="réduction-de-dimensionnalité-feature-extraction" class="level3">
<h3 class="anchored" data-anchor-id="réduction-de-dimensionnalité-feature-extraction">8.1 Réduction de Dimensionnalité (Feature Extraction)</h3>
<p>Dans les contextes de “High-Dimensional Low-Sample Size” (HDLSS), comme en génomique ou chimiométrie, VAR_KMEANS permet de résumer des milliers de variables corrélées en quelques composantes synthétiques interprétables, sans les problèmes de multicolinéarité.</p>
</section>
<section id="analyse-sensorielle" class="level3">
<h3 class="anchored" data-anchor-id="analyse-sensorielle">8.2 Analyse Sensorielle</h3>
<p>Pour regrouper des descripteurs sensoriels (ex: “fruité”, “sucré”, “agrumes”) qui covarient, et identifier les dimensions latentes de perception des produits.</p>
</section>
</section>
<section id="références-théoriques" class="level2">
<h2 class="anchored" data-anchor-id="références-théoriques">9. Références Théoriques</h2>
<section id="algorithme-de-base" class="level3">
<h3 class="anchored" data-anchor-id="algorithme-de-base">9.1 Algorithme de Base</h3>
<ul>
<li><strong>Vigneau, E., &amp; Qannari, E. M. (2003)</strong>. <em>Clustering of variables around latent components</em>. Communications in Statistics-Simulation and Computation, 32(4), 1131-1150. &gt; Article fondateur décrivant l’algorithme itératif avec recentrage sur la composante principale.</li>
</ul>
</section>
<section id="implémentation-de-référence" class="level3">
<h3 class="anchored" data-anchor-id="implémentation-de-référence">9.2 Implémentation de Référence</h3>
<ul>
<li><p><strong>Chavent, M., Kuentz-Simonet, V., Liquet, B., &amp; Saracco, J. (2012)</strong>. <em>ClustOfVar: An R Package for the Clustering of Variables</em>. Journal of Statistical Software, 50(13), 1-16. &gt; Description du package R standard pour ces méthodes, dont s’inspire cette implémentation R6.</p>
<hr></li>
</ul>
<p><strong>Document rédigé dans le cadre du développement du package R <code>RollerClustR</code></strong><br>
<strong>Auteur</strong> : Romain Buono <strong>Date</strong> : Novembre 2025<br>
<strong>Licence</strong> : MIT</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>